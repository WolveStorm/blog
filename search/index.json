[{"content":"grpc 初识protobuffer 1 go get -u github.com/golang/protobuf/protoc-gen-go 第一个proto proto文件都需要以.proto作为后缀。\n下面就是一个简单的protobuffer，name = 1不是指他的值是1，而是指他在Person中的序号是1.\noption go_package = \u0026ldquo;path;package\u0026rdquo;\npath代表生成的go文件在当前目录，package代表包为first。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 syntax = \u0026#34;proto3\u0026#34;; option go_package=\u0026#34;./;first\u0026#34;; package first; message Person{ string name = 1; int32 age = 2; string email = 3; enum status{ CHILD=0; ADULT=1; OLD = 2; } } 生成go文件 protoc \u0026ndash;go_out= . ./*.proto\n生成的pb.go文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 // Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.28.0 // protoc v3.20.0 // source: person.proto package first import ( protoreflect \u0026#34;google.golang.org/protobuf/reflect/protoreflect\u0026#34; protoimpl \u0026#34;google.golang.org/protobuf/runtime/protoimpl\u0026#34; reflect \u0026#34;reflect\u0026#34; sync \u0026#34;sync\u0026#34; ) const ( // Verify that this generated code is sufficiently up-to-date. _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion) // Verify that runtime/protoimpl is sufficiently up-to-date. _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20) ) type PersonStatus int32 const ( Person_CHILD PersonStatus = 0 Person_ADULT PersonStatus = 1 Person_OLD PersonStatus = 2 ) // Enum value maps for PersonStatus. var ( PersonStatus_name = map[int32]string{ 0: \u0026#34;CHILD\u0026#34;, 1: \u0026#34;ADULT\u0026#34;, 2: \u0026#34;OLD\u0026#34;, } PersonStatus_value = map[string]int32{ \u0026#34;CHILD\u0026#34;: 0, \u0026#34;ADULT\u0026#34;: 1, \u0026#34;OLD\u0026#34;: 2, } ) func (x PersonStatus) Enum() *PersonStatus { p := new(PersonStatus) *p = x return p } func (x PersonStatus) String() string { return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x)) } func (PersonStatus) Descriptor() protoreflect.EnumDescriptor { return file_person_proto_enumTypes[0].Descriptor() } func (PersonStatus) Type() protoreflect.EnumType { return \u0026amp;file_person_proto_enumTypes[0] } func (x PersonStatus) Number() protoreflect.EnumNumber { return protoreflect.EnumNumber(x) } // Deprecated: Use PersonStatus.Descriptor instead. func (PersonStatus) EnumDescriptor() ([]byte, []int) { return file_person_proto_rawDescGZIP(), []int{0, 0} } type Person struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Name string `protobuf:\u0026#34;bytes,1,opt,name=name,proto3\u0026#34; json:\u0026#34;name,omitempty\u0026#34;` Age int32 `protobuf:\u0026#34;varint,2,opt,name=age,proto3\u0026#34; json:\u0026#34;age,omitempty\u0026#34;` Email string `protobuf:\u0026#34;bytes,3,opt,name=email,proto3\u0026#34; json:\u0026#34;email,omitempty\u0026#34;` } func (x *Person) Reset() { *x = Person{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_person_proto_msgTypes[0] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *Person) String() string { return protoimpl.X.MessageStringOf(x) } func (*Person) ProtoMessage() {} func (x *Person) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_person_proto_msgTypes[0] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use Person.ProtoReflect.Descriptor instead. func (*Person) Descriptor() ([]byte, []int) { return file_person_proto_rawDescGZIP(), []int{0} } func (x *Person) GetName() string { if x != nil { return x.Name } return \u0026#34;\u0026#34; } func (x *Person) GetAge() int32 { if x != nil { return x.Age } return 0 } func (x *Person) GetEmail() string { if x != nil { return x.Email } return \u0026#34;\u0026#34; } var File_person_proto protoreflect.FileDescriptor var file_person_proto_rawDesc = []byte{ 0x0a, 0x0c, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 0x22, 0x6d, 0x0a, 0x06, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x27, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x09, 0x0a, 0x05, 0x43, 0x48, 0x49, 0x4c, 0x44, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x41, 0x44, 0x55, 0x4c, 0x54, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x4f, 0x4c, 0x44, 0x10, 0x02, 0x42, 0x0a, 0x5a, 0x08, 0x2e, 0x2f, 0x3b, 0x66, 0x69, 0x72, 0x73, 0x74, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33, } var ( file_person_proto_rawDescOnce sync.Once file_person_proto_rawDescData = file_person_proto_rawDesc ) func file_person_proto_rawDescGZIP() []byte { file_person_proto_rawDescOnce.Do(func() { file_person_proto_rawDescData = protoimpl.X.CompressGZIP(file_person_proto_rawDescData) }) return file_person_proto_rawDescData } var file_person_proto_enumTypes = make([]protoimpl.EnumInfo, 1) var file_person_proto_msgTypes = make([]protoimpl.MessageInfo, 1) var file_person_proto_goTypes = []interface{}{ (PersonStatus)(0), // 0: first.Person.status (*Person)(nil), // 1: first.Person } var file_person_proto_depIdxs = []int32{ 0, // [0:0] is the sub-list for method output_type 0, // [0:0] is the sub-list for method input_type 0, // [0:0] is the sub-list for extension type_name 0, // [0:0] is the sub-list for extension extendee 0, // [0:0] is the sub-list for field type_name } func init() { file_person_proto_init() } func file_person_proto_init() { if File_person_proto != nil { return } if !protoimpl.UnsafeEnabled { file_person_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*Person); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } } type x struct{} out := protoimpl.TypeBuilder{ File: protoimpl.DescBuilder{ GoPackagePath: reflect.TypeOf(x{}).PkgPath(), RawDescriptor: file_person_proto_rawDesc, NumEnums: 1, NumMessages: 1, NumExtensions: 0, NumServices: 0, }, GoTypes: file_person_proto_goTypes, DependencyIndexes: file_person_proto_depIdxs, EnumInfos: file_person_proto_enumTypes, MessageInfos: file_person_proto_msgTypes, }.Build() File_person_proto = out.File file_person_proto_rawDesc = nil file_person_proto_goTypes = nil file_person_proto_depIdxs = nil } 序列化和反序列化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/golang/protobuf/proto\u0026#34; ) func main() { p := \u0026amp;Person{Name: \u0026#34;phm\u0026#34;,Age: 12,Email: \u0026#34;8888888@qq.com\u0026#34;} //序列化 marshal, _ := proto.Marshal(p) fmt.Println(marshal) newP := \u0026amp;Person{} //反序列化 _ = proto.Unmarshal(marshal, newP) fmt.Println(newP) } proto和json的相互转换 首先安装一个包\n1 go get google.golang.org/protobuf/encoding/protojson 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;google.golang.org/protobuf/encoding/protojson\u0026#34; ) func main() { p := \u0026amp;Person{ Name: \u0026#34;phm\u0026#34;, Age: 13, Email: \u0026#34;999999@qq.com\u0026#34;, } format := protojson.Format(p.ProtoReflect().Interface()) fmt.Println(format) message := p.ProtoReflect().Interface() _ = protojson.Unmarshal([]byte(format), message) fmt.Println(message) } 在protobuffer中定义服务 如果你想在RPC(远程过程调用）系统中使用你的消息类型，你可以在一个.proto文件中定义一个RPC服务接口，并且Protocol Buffers编译器将以你选择的语言生成服务接口代码和存根。因此，例如，如果你想定义一个RPC服务，它的方法接受你的SeanchRequest并返回一个SeanchResponse，你可以在你的.proto文件中定义它，如下所示:\n1 2 3 4 service RpcService{ rpc Search(Person) returns (Person); rpc register(Person) returns (Person); } 初识rpc 在上述本地过程调用的例子中，我们是在一台计算机上执行了计算机上的程序，完成调用。随着计算机技术的发展和需求场景的变化，有时就需要从一台计算机上执行另外一台计算机上的程序的需求，因此后来又发展出来了RPC技术。特别是目前随着互联网技术的快速迭代和发展，用户和需求几乎都是以指数式的方式在高速增长，这个时候绝大多数情况下程序都是部署在多台机器上，就需要在调用其他物理机器上的程序的情况。\nRPC是Remote Procedure Call Protocol单词首字母的缩写，简称为：RPC，翻译成中文叫远程过程调用协议。所谓远程过程调用，通俗的理解就是可以在本地程序中调用运行在另外一台服务器上的程序的功能方法。这种调用的过程跨越了物理服务器的限制，是在网络中完成的，在调用远端服务器上程序的过程中，本地程序等待返回调用结果，直到远端程序执行完毕，将结果进行返回到本地，最终完成一次完整的调用。\n需要强调的是：远程过程调用指的是调用远端服务器上的程序的方法整个过程。\nrpc的组成 RPC技术在架构设计上有四部分组成，分别是：客户端、客户端存根、服务端、服务端存根。\n这里提到了客户端和服务端的概念，其属于程序设计架构的一种方式，在现代的计算机软件程序架构设计上，大方向上分为两种方向，分别是：B/S架构、C/S架构。B/S架构指的是浏览器到服务器交互的架构方式，另外一种是在计算机上安装一个单独的应用，称之为客户端，与服务器交互的模式。\n由于在服务的调用过程中，有一方是发起调用方，另一方是提供服务方。因此，我们把服务发起方称之为客户端，把服务提供方称之为服务端。以下是对RPC的四种角色的解释和说明：\n**客户端(Client)：**服务调用发起方，也称为服务消费者。 **客户端存根(Client Stub)：**该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。 **服务端(Server)：**远端的计算机机器上运行的程序，其中有客户端要调用的方法。 **服务端存根(Server Stub)：**接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。 rpc的原理 了解完了RPC技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：\n两台物理机器在网络中要建立稳定可靠的通信连接。 两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。 让我们来看看RPC具体是如何解决这些问题的，RPC具体的调用步骤图如下：\n在上述图中，通过1-10的步骤图解的形式，说明了RPC每一步的调用过程。具体描述为：\n1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名； 2、客户端Stub程序接收到了客户端的功能调用请求，将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。 3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。 4、服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。 5、服务端Stub程序准备相关数据，调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。 6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。 7、服务端Stub程序**将程序调用结果按照约定的协议进行序列化，**并通过网络发送回客户端Stub程序。 8、客户端Stub程序接收到服务端Stub发送的返回数据，**对数据进行反序列化操作，**并将调用返回的数据传递给客户端请求发起者。 9、客户端请求发起者得到调用结果，整个RPC调用过程结束。 go实现rpc 在Go语言官方网站的pkg说明中，提供了官方支持的rpc包，具体链接如下：https://golang.org/pkg/net/rpc/。官方提供的rpc包完整的包名是：net/rpc。根据官方的解释，rpc包主要是提供通过网络访问一个对象方法的功能。\n本节课，我们就来学习如何使用go语言官方提供的RPC包实现RPC调用编码。\n服务定义和暴露 1 func (t *T) MethodName(request T1,response *T2) error 上述代码是go语言官方给出的对外暴露的服务方法的定义标准，其中包含了主要的几条规则，分别是：\n1、对外暴露的方法有且只能有两个参数，这个两个参数只能是输出类型或内建类型，两种类型中的一种。 2、方法的第二个参数必须是指针类型。 3、方法的返回类型为error。 4、方法的类型是可输出的。 5、方法本身也是可输出的。 我们举例说明：假设目前我们有一个需求，给出一个float类型变量，作为圆形的半径，要求通过RPC调用，返回对应的圆形面积。具体的编程实现思路如下：\n1 2 3 4 5 6 7 type MathUtil struct{ } //该方法向外暴露：提供计算圆形面积的服务 func (mu *MathUtil) CalculateCircleArea(req float32, resp *float32) error { *resp = math.Pi * req * req //圆形的面积 s = π * r * r return nil //返回类型 } 注册服务和监听 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;math\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; ) type MathUtil struct { } func (m *MathUtil)mathFunc(req float32,resp *float32)error{ *resp = math.Pi * req * req return nil } func main() { //初始化指针类型 m := new(MathUtil) //注册服务 err := rpc.Register(m) if err != nil{ panic(err.Error()) } //3、通过该函数把mathUtil中提供的服务注册到HTTP协议上，方便调用者可以利用http的方式进行数据传递 rpc.HandleHTTP() //4、在特定端口监听 listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(err.Error()) } go http.Serve(listen,nil) } 经过服务注册和监听处理，RPC调用过程中的服务端实现就已经完成了。接下来需要实现的是客户端请求代码的实现。\n客户端调用 上述的调用方法核心在于client.Call方法的调用，该方法有三个参数，第一个参数表示要调用的远端服务的方法名，第二个参数是调用时要传入的参数，第三个参数是调用要接收的返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/rpc\u0026#34; ) func main() { //连接服务器 client, err := rpc.DialHTTP(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8081\u0026#34;) if err != nil{ panic(err.Error()) } var req float32 //请求值 req = 3 var resp float32 //返回值 //调用服务 err = client.Call(\u0026#34;MathUtil.MathFunc\u0026#34;, req, \u0026amp;resp) if err != nil { panic(err.Error()) } fmt.Println(resp) } 客户端异步调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func main() { //连接服务器 client, err := rpc.DialHTTP(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8081\u0026#34;) if err != nil{ panic(err.Error()) } var req float32 //请求值 req = 3 var resp float32 //返回值 //调用服务 call := client.Go(\u0026#34;MathUtil.MathFunc\u0026#34;, req, \u0026amp;resp, nil) if err != nil { panic(err.Error()) } replyDone := \u0026lt;-call.Done fmt.Println(resp) fmt.Println(replyDone) } 多参数传递 1 2 3 4 type AddParma struct { Args1 float32 //第一个参数 Args2 float32 //第二个参数 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (mu *MathUtil) Add(param param.AddParma, resp *float32) error { *resp = param.Args1 + param.Args2 //实现两数相加的功能 return nil } mathUtil := new(MathUtil) err := rpc.RegisterName(\u0026#34;MathUtil\u0026#34;, mathUtil) if err != nil { panic(err.Error()) } rpc.HandleHTTP() listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8082\u0026#34;) http.Serve(listen, nil) rpc和protobuffer 首先可以将call函数中的req和resp都用protobuffer生成。其他步骤类似\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 syntax=\u0026#34;proto3\u0026#34;; option go_package=\u0026#34;./;rpcAndproto\u0026#34;; //订单请求参数 message OrderRequest { string orderId = 1; int64 timeStamp = 2; } //订单信息 message OrderInfo { string OrderId = 1; string OrderName = 2; string OrderStatus = 3; } service OrderService{ rpc GetOrderInfo(OrderRequest) returns (OrderInfo); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 // Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.28.0 // protoc v3.20.0 // source: Order.proto package rpcAndproto import ( protoreflect \u0026#34;google.golang.org/protobuf/reflect/protoreflect\u0026#34; protoimpl \u0026#34;google.golang.org/protobuf/runtime/protoimpl\u0026#34; reflect \u0026#34;reflect\u0026#34; sync \u0026#34;sync\u0026#34; ) const ( // Verify that this generated code is sufficiently up-to-date. _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion) // Verify that runtime/protoimpl is sufficiently up-to-date. _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20) ) //订单请求参数 type OrderRequest struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields OrderId string `protobuf:\u0026#34;bytes,1,opt,name=orderId,proto3\u0026#34; json:\u0026#34;orderId,omitempty\u0026#34;` TimeStamp int64 `protobuf:\u0026#34;varint,2,opt,name=timeStamp,proto3\u0026#34; json:\u0026#34;timeStamp,omitempty\u0026#34;` } func (x *OrderRequest) Reset() { *x = OrderRequest{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_Order_proto_msgTypes[0] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *OrderRequest) String() string { return protoimpl.X.MessageStringOf(x) } func (*OrderRequest) ProtoMessage() {} func (x *OrderRequest) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_Order_proto_msgTypes[0] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use OrderRequest.ProtoReflect.Descriptor instead. func (*OrderRequest) Descriptor() ([]byte, []int) { return file_Order_proto_rawDescGZIP(), []int{0} } func (x *OrderRequest) GetOrderId() string { if x != nil { return x.OrderId } return \u0026#34;\u0026#34; } func (x *OrderRequest) GetTimeStamp() int64 { if x != nil { return x.TimeStamp } return 0 } //订单信息 type OrderInfo struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields OrderId string `protobuf:\u0026#34;bytes,1,opt,name=OrderId,proto3\u0026#34; json:\u0026#34;OrderId,omitempty\u0026#34;` OrderName string `protobuf:\u0026#34;bytes,2,opt,name=OrderName,proto3\u0026#34; json:\u0026#34;OrderName,omitempty\u0026#34;` OrderStatus string `protobuf:\u0026#34;bytes,3,opt,name=OrderStatus,proto3\u0026#34; json:\u0026#34;OrderStatus,omitempty\u0026#34;` } func (x *OrderInfo) Reset() { *x = OrderInfo{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_Order_proto_msgTypes[1] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *OrderInfo) String() string { return protoimpl.X.MessageStringOf(x) } func (*OrderInfo) ProtoMessage() {} func (x *OrderInfo) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_Order_proto_msgTypes[1] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use OrderInfo.ProtoReflect.Descriptor instead. func (*OrderInfo) Descriptor() ([]byte, []int) { return file_Order_proto_rawDescGZIP(), []int{1} } func (x *OrderInfo) GetOrderId() string { if x != nil { return x.OrderId } return \u0026#34;\u0026#34; } func (x *OrderInfo) GetOrderName() string { if x != nil { return x.OrderName } return \u0026#34;\u0026#34; } func (x *OrderInfo) GetOrderStatus() string { if x != nil { return x.OrderStatus } return \u0026#34;\u0026#34; } var File_Order_proto protoreflect.FileDescriptor var file_Order_proto_rawDesc = []byte{ 0x0a, 0x0b, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x46, 0x0a, 0x0c, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x53, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x65, 0x0a, 0x09, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1c, 0x0a, 0x09, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x32, 0x39, 0x0a, 0x0c, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x29, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0d, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x0a, 0x2e, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x10, 0x5a, 0x0e, 0x2e, 0x2f, 0x3b, 0x72, 0x70, 0x63, 0x41, 0x6e, 0x64, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33, } var ( file_Order_proto_rawDescOnce sync.Once file_Order_proto_rawDescData = file_Order_proto_rawDesc ) func file_Order_proto_rawDescGZIP() []byte { file_Order_proto_rawDescOnce.Do(func() { file_Order_proto_rawDescData = protoimpl.X.CompressGZIP(file_Order_proto_rawDescData) }) return file_Order_proto_rawDescData } var file_Order_proto_msgTypes = make([]protoimpl.MessageInfo, 2) var file_Order_proto_goTypes = []interface{}{ (*OrderRequest)(nil), // 0: OrderRequest (*OrderInfo)(nil), // 1: OrderInfo } var file_Order_proto_depIdxs = []int32{ 0, // 0: OrderService.GetOrderInfo:input_type -\u0026gt; OrderRequest 1, // 1: OrderService.GetOrderInfo:output_type -\u0026gt; OrderInfo 1, // [1:2] is the sub-list for method output_type 0, // [0:1] is the sub-list for method input_type 0, // [0:0] is the sub-list for extension type_name 0, // [0:0] is the sub-list for extension extendee 0, // [0:0] is the sub-list for field type_name } func init() { file_Order_proto_init() } func file_Order_proto_init() { if File_Order_proto != nil { return } if !protoimpl.UnsafeEnabled { file_Order_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*OrderRequest); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } file_Order_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*OrderInfo); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } } type x struct{} out := protoimpl.TypeBuilder{ File: protoimpl.DescBuilder{ GoPackagePath: reflect.TypeOf(x{}).PkgPath(), RawDescriptor: file_Order_proto_rawDesc, NumEnums: 0, NumMessages: 2, NumExtensions: 0, NumServices: 1, }, GoTypes: file_Order_proto_goTypes, DependencyIndexes: file_Order_proto_depIdxs, MessageInfos: file_Order_proto_msgTypes, }.Build() File_Order_proto = out.File file_Order_proto_rawDesc = nil file_Order_proto_goTypes = nil file_Order_proto_depIdxs = nil } 服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;errors\u0026#34; \u0026#34;goTrip/rpcAndproto\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;time\u0026#34; ) type OrderService struct { } func (o *OrderService) GetAccount(request rpcAndproto.OrderRequest,response *rpcAndproto.OrderInfo) error{ orderMap := map[string]rpcAndproto.OrderInfo{ \u0026#34;201907300001\u0026#34;: rpcAndproto.OrderInfo{OrderId: \u0026#34;201907300001\u0026#34;, OrderName: \u0026#34;衣服\u0026#34;, OrderStatus: \u0026#34;已付款\u0026#34;}, \u0026#34;201907310001\u0026#34;: rpcAndproto.OrderInfo{OrderId: \u0026#34;201907310001\u0026#34;, OrderName: \u0026#34;零食\u0026#34;, OrderStatus: \u0026#34;已付款\u0026#34;}, \u0026#34;201907310002\u0026#34;: rpcAndproto.OrderInfo{OrderId: \u0026#34;201907310002\u0026#34;, OrderName: \u0026#34;食品\u0026#34;, OrderStatus: \u0026#34;未付款\u0026#34;}, } current := time.Now().Unix() if (request.TimeStamp \u0026gt; current) { *response = rpcAndproto.OrderInfo{OrderId: \u0026#34;0\u0026#34;, OrderName: \u0026#34;\u0026#34;, OrderStatus: \u0026#34;订单信息异常\u0026#34;} } else { result := orderMap[request.OrderId]//201907310003 if result.OrderId != \u0026#34;\u0026#34; { *response = orderMap[request.OrderId] } else { return errors.New(\u0026#34;server error\u0026#34;) } } return nil } func main() { o := new(OrderService) err := rpc.Register(o) if err != nil{ panic(err) } rpc.HandleHTTP() listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(err) } http.Serve(listen,nil) } 客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;goTrip/rpcAndproto\u0026#34; \u0026#34;net/rpc\u0026#34; \u0026#34;time\u0026#34; ) func main() { client, err := rpc.DialHTTP(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:8081\u0026#34;) if err != nil { panic(err.Error()) } timeStamp := time.Now().Unix() request := rpcAndproto.OrderRequest{OrderId: \u0026#34;201907310001\u0026#34;, TimeStamp: timeStamp} var response *rpcAndproto.OrderInfo err = client.Call(\u0026#34;OrderService.GetAccount\u0026#34;, request, \u0026amp;response) if err != nil { panic(err.Error()) } fmt.Println(*response) } 初识grpc 得到grpc 1 go get -u google.golang.org/grpc grpc的使用 我们想要实现的是通过gRPC框架进行远程服务调用，首先第一步应该是要有服务。利用之前所掌握的内容，gRPC框架支持对服务的定义和生成。 gRPC框架默认使用protocol buffers作为接口定义语言，用于描述网络传输消息结构。除此之外，还可以使用protobuf定义服务接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 syntax = \u0026#34;proto3\u0026#34;; package message; //订单请求参数 message OrderRequest { string orderId = 1; int64 timeStamp = 2; } //订单信息 message OrderInfo { string OrderId = 1; string OrderName = 2; string OrderStatus = 3; } //订单服务service定义 service OrderService{ rpc GetOrderInfo(OrderRequest) returns (OrderInfo); } gRPC编译支持 如果定义的.proto文件，如本案例中所示，定义中包含了服务接口的定义，而我们想要使用gRPC框架实现RPC调用。开发者可以采用protocol-gen-go库提供的插件编译功能，生成兼容gRPC框架的golang语言代码。只需要在基本编译命令的基础上，指定插件的参数，告知protoc编译器即可。具体的编译生成兼容gRPC框架的服务代码的命令如下：\n1 protoc --go_out=plugins=grpc:. *.proto pb.go生成的客户端方法代码，给了生成客户端的方法，给了调用服务的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // OrderServiceClient is the client API for OrderService service. // // For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream. type OrderServiceClient interface { GetOrderInfo(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (*OrderInfo, error) } type orderServiceClient struct { cc grpc.ClientConnInterface } func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient { return \u0026amp;orderServiceClient{cc} } func (c *orderServiceClient) GetOrderInfo(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (*OrderInfo, error) { out := new(OrderInfo) err := c.cc.Invoke(ctx, \u0026#34;/OrderService/GetOrderInfo\u0026#34;, in, out, opts...) if err != nil { return nil, err } return out, nil } pb.go生成的服务器方法代码，提供了注册已实现OrderService接口的方法，定义了一个没有实现方法的类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // OrderServiceServer is the server API for OrderService service. type OrderServiceServer interface { GetOrderInfo(context.Context, *OrderRequest) (*OrderInfo, error) } // UnimplementedOrderServiceServer can be embedded to have forward compatible implementations. type UnimplementedOrderServiceServer struct { } func (*UnimplementedOrderServiceServer) GetOrderInfo(context.Context, *OrderRequest) (*OrderInfo, error) { return nil, status.Errorf(codes.Unimplemented, \u0026#34;method GetOrderInfo not implemented\u0026#34;) } func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) { s.RegisterService(\u0026amp;_OrderService_serviceDesc, srv) } 实现rpc服务 在上面的proto文件中定义的方法，我们可以发现并没有方法体，类似于接口，我们要实现这个方法。\n对于实现的方法，参数会对应的改变。\n1 func (os *OrderServiceImpl)GetOrderInfo(ctx context.Context,request *grpc.OrderRequest)(*grpc.OrderInfo,error) grpc实现服务器 这里由于我的包名设置成了grpc（方便复习），所以将google的grpc起别名成了Grpc\n1 2 3 4 5 6 7 8 9 func main() { server := Grpc.NewServer() grpc.RegisterOrderServiceServer(server,new(OrderServiceImpl)) listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(err) } server.Serve(listen) } grpc实现客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/net/context\u0026#34; Grpc \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;goTrip/grpc\u0026#34; \u0026#34;time\u0026#34; ) func main() { conn, err := Grpc.Dial(\u0026#34;localhost:8081\u0026#34;, Grpc.WithInsecure()) if err != nil{ panic(err) } defer conn.Close() //从proto中获得连接服务的客户端 client := grpc.NewOrderServiceClient(conn) req := \u0026amp;grpc.OrderRequest{ OrderId: \u0026#34;201907300001\u0026#34;, TimeStamp: time.Now().Unix(), } info, err := client.GetOrderInfo(context.Background(), req) if info != nil{ fmt.Println(info.GetOrderId()) fmt.Println(info.GetOrderName()) fmt.Println(info.GetOrderStatus()) } } grpc的流模式 在上节课内容中，我们学习了使用gRPC框架实现服务的调用编程。在gRPC框架中，诸如上节课我们学习的在客户端与服务端之间通过消息结构体定义的方式来传递数据，我们称之为“单项RPC”，也称之为简单模式。除此之外，gRPC中还有数据流模式的RPC调用实现，这正是我们本节课要学习的内容。\n服务器流形式 定义proto文件 这一次的proto文件和上一个Cs模式的有些许不同，return的带有stream\n1 2 3 service OrderService { rpc GetOrderInfos (OrderRequest) returns (stream OrderInfo) {}; //服务端流模式 } 通过stream修饰的方式表示该接口调用时，服务端会以数据流的形式将数据返回给客户端。\n1 protoc --go_out=plugins=grpc:. ./*.proto 生成的文件也会有些许不同。\n对于方法方面，客户端如下，发现相较于上面的非流传输，多了一个recv函数，这个应该时用来接受服务器传过来的OrderInfo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient { return \u0026amp;orderServiceClient{cc} } func (c *orderServiceClient) GetOrderInfo(ctx context.Context, in *OrderRequest, opts ...grpc.CallOption) (OrderService_GetOrderInfoClient, error) { stream, err := c.cc.NewStream(ctx, \u0026amp;_OrderService_serviceDesc.Streams[0], \u0026#34;/OrderService/GetOrderInfo\u0026#34;, opts...) if err != nil { return nil, err } x := \u0026amp;orderServiceGetOrderInfoClient{stream} if err := x.ClientStream.SendMsg(in); err != nil { return nil, err } if err := x.ClientStream.CloseSend(); err != nil { return nil, err } return x, nil } type OrderService_GetOrderInfoClient interface { Recv() (*OrderInfo, error) grpc.ClientStream } type orderServiceGetOrderInfoClient struct { grpc.ClientStream } func (x *orderServiceGetOrderInfoClient) Recv() (*OrderInfo, error) { m := new(OrderInfo) if err := x.ClientStream.RecvMsg(m); err != nil { return nil, err } return m, nil } 服务器这边也是，多了一个send方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // OrderServiceServer is the server API for OrderService service. type OrderServiceServer interface { GetOrderInfo(*OrderRequest, OrderService_GetOrderInfoServer) error } // UnimplementedOrderServiceServer can be embedded to have forward compatible implementations. type UnimplementedOrderServiceServer struct { } func (*UnimplementedOrderServiceServer) GetOrderInfo(*OrderRequest, OrderService_GetOrderInfoServer) error { return status.Errorf(codes.Unimplemented, \u0026#34;method GetOrderInfo not implemented\u0026#34;) } func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) { s.RegisterService(\u0026amp;_OrderService_serviceDesc, srv) } func _OrderService_GetOrderInfo_Handler(srv interface{}, stream grpc.ServerStream) error { m := new(OrderRequest) if err := stream.RecvMsg(m); err != nil { return err } return srv.(OrderServiceServer).GetOrderInfo(m, \u0026amp;orderServiceGetOrderInfoServer{stream}) } type OrderService_GetOrderInfoServer interface { Send(*OrderInfo) error grpc.ServerStream } type orderServiceGetOrderInfoServer struct { grpc.ServerStream } func (x *orderServiceGetOrderInfoServer) Send(m *OrderInfo) error { return x.ServerStream.SendMsg(m) } 服务器 由于服务器用的流形式回传，所以参数中带有OrderService_GetOrderInfoServer这个含有send方法的接口，用于传输流。\n1 2 3 4 type OrderService_GetOrderInfoServer interface { Send(*OrderInfo) error grpc.ServerStream } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func (os *OrderServiceImpl) GetOrderInfos(request *streamRpc.OrderRequest, stream streamRpc.OrderService_GetOrderInfoServer) error { fmt.Println(\u0026#34; 服务端流 RPC 模式\u0026#34;) orderMap := map[string]streamRpc.OrderInfo{ \u0026#34;201907300001\u0026#34;: streamRpc.OrderInfo{OrderId: \u0026#34;201907300001\u0026#34;, OrderName: \u0026#34;衣服\u0026#34;, OrderStatus: \u0026#34;已付款\u0026#34;}, \u0026#34;201907310001\u0026#34;: streamRpc.OrderInfo{OrderId: \u0026#34;201907310001\u0026#34;, OrderName: \u0026#34;零食\u0026#34;, OrderStatus: \u0026#34;已付款\u0026#34;}, \u0026#34;201907310002\u0026#34;: streamRpc.OrderInfo{OrderId: \u0026#34;201907310002\u0026#34;, OrderName: \u0026#34;食品\u0026#34;, OrderStatus: \u0026#34;未付款\u0026#34;}, } for id, info := range orderMap { if (time.Now().Unix() \u0026gt;= request.TimeStamp) { fmt.Println(\u0026#34;订单序列号ID：\u0026#34;, id) fmt.Println(\u0026#34;订单详情：\u0026#34;, info) //通过流模式发送给客户端 stream.Send(\u0026amp;info) } } return nil } 服务的监听与处理与前文所学内容没有区别，依然是相同的步骤:\n1 2 3 4 5 6 7 8 9 func main() { server := grpc.NewServer() streamRpc.RegisterOrderServiceServer(server,new(OrderServiceImpl)) listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(nil) } server.Serve(listen) } 客户端 服务端使用Send方法将数据以流的形式进行发送，客户端可以使用Recv()方法接收流数据,因为数据流失源源不断的，因此使用for无限循环实现数据流的读取，当读取到io.EOF时，表示流数据结束。客户端数据读取实现如下\n先还是拨号到指定端口，然后就可以创建一个client调用服务，服务会返回一个OrderService_GetOrderInfoClient，该接口实现了Recv，我们直接调用Recv方法接受信息即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;goTrip/streamRpc\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;io\u0026#34; \u0026#34;time\u0026#34; ) func main() { conn, err := grpc.Dial(\u0026#34;localhost:8081\u0026#34;, grpc.WithInsecure()) if err != nil{ panic(err) } defer conn.Close() client := streamRpc.NewOrderServiceClient(conn) req := \u0026amp;streamRpc.OrderRequest{ OrderId: \u0026#34;201907300001\u0026#34;, TimeStamp: time.Now().Unix(), } stream, err := client.GetOrderInfo(context.Background(), req) for{ recv, err := stream.Recv() if err == io.EOF{ break } if err != nil{ panic(err) } fmt.Println(\u0026#34;读取的消息:\u0026#34;,recv) } } 客户端流模式 定义proto文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 syntax = \u0026#34;proto3\u0026#34;; option go_package=\u0026#34;./;streamRpc\u0026#34;; //订单请求参数 message OrderRequest { string orderId = 1; int64 timeStamp = 2; } //订单信息 message OrderInfo { string OrderId = 1; string OrderName = 2; string OrderStatus = 3; } service OrderService { rpc AddOrderList (stream OrderRequest) returns (OrderInfo) {}; //客户端流模式 } 生成的客户端文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 type OrderServiceClient interface { GetOrderInfo(ctx context.Context, opts ...grpc.CallOption) (OrderService_GetOrderInfoClient, error) } type orderServiceClient struct { cc grpc.ClientConnInterface } func NewOrderServiceClient(cc grpc.ClientConnInterface) OrderServiceClient { return \u0026amp;orderServiceClient{cc} } func (c *orderServiceClient) GetOrderInfo(ctx context.Context, opts ...grpc.CallOption) (OrderService_GetOrderInfoClient, error) { stream, err := c.cc.NewStream(ctx, \u0026amp;_OrderService_serviceDesc.Streams[0], \u0026#34;/OrderService/GetOrderInfo\u0026#34;, opts...) if err != nil { return nil, err } x := \u0026amp;orderServiceGetOrderInfoClient{stream} return x, nil } type OrderService_GetOrderInfoClient interface { Send(*OrderRequest) error CloseAndRecv() (*OrderInfo, error) grpc.ClientStream } type orderServiceGetOrderInfoClient struct { grpc.ClientStream } func (x *orderServiceGetOrderInfoClient) Send(m *OrderRequest) error { return x.ClientStream.SendMsg(m) } func (x *orderServiceGetOrderInfoClient) CloseAndRecv() (*OrderInfo, error) { if err := x.ClientStream.CloseSend(); err != nil { return nil, err } m := new(OrderInfo) if err := x.ClientStream.RecvMsg(m); err != nil { return nil, err } return m, nil } SendAndClose和Recv方法是客户端流模式下的服务端对象所拥有的方法。\n服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 type OrderServiceServer interface { GetOrderInfo(OrderService_GetOrderInfoServer) error } // UnimplementedOrderServiceServer can be embedded to have forward compatible implementations. type UnimplementedOrderServiceServer struct { } func (*UnimplementedOrderServiceServer) GetOrderInfo(OrderService_GetOrderInfoServer) error { return status.Errorf(codes.Unimplemented, \u0026#34;method GetOrderInfo not implemented\u0026#34;) } func RegisterOrderServiceServer(s *grpc.Server, srv OrderServiceServer) { s.RegisterService(\u0026amp;_OrderService_serviceDesc, srv) } func _OrderService_GetOrderInfo_Handler(srv interface{}, stream grpc.ServerStream) error { return srv.(OrderServiceServer).GetOrderInfo(\u0026amp;orderServiceGetOrderInfoServer{stream}) } type OrderService_GetOrderInfoServer interface { SendAndClose(*OrderInfo) error Recv() (*OrderRequest, error) grpc.ServerStream } type orderServiceGetOrderInfoServer struct { grpc.ServerStream } func (x *orderServiceGetOrderInfoServer) SendAndClose(m *OrderInfo) error { return x.ServerStream.SendMsg(m) } func (x *orderServiceGetOrderInfoServer) Recv() (*OrderRequest, error) { m := new(OrderRequest) if err := x.ServerStream.RecvMsg(m); err != nil { return nil, err } return m, nil } Send和CloseAndRecv是客户端流模式下的客户端对象所拥有的方法。\n服务器实现 由于信息全在流中，所以不需要req了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (os *OrderServiceImpl) AddOrderList(stream streamRpc.OrderService_AddOrderListServer) error { fmt.Println(\u0026#34; 客户端 RPC 模式\u0026#34;) for { recv, err := stream.Recv() if err == io.EOF { fmt.Println(\u0026#34; 读取数据结束 \u0026#34;) result := streamRpc.OrderInfo{OrderStatus: \u0026#34; 读取数据结束 \u0026#34;} return stream.SendAndClose(\u0026amp;result) } if err != nil { fmt.Println(err.Error()) return err } fmt.Println(recv) } return nil } 监听服务器依然差不多\n1 2 3 4 5 6 7 8 9 func main() { server := grpc.NewServer() streamRpc.RegisterOrderServiceServer(server,new(OrderServiceImpl)) listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(nil) } server.Serve(listen) } 客户端实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;goTrip/streamRpc\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;io\u0026#34; \u0026#34;time\u0026#34; ) func main() { orderMap := map[string]streamRpc.OrderRequest{ \u0026#34;201907300001\u0026#34;: streamRpc.OrderRequest{OrderId: \u0026#34;201907300001\u0026#34;,TimeStamp: time.Now().Unix()}, \u0026#34;201907310001\u0026#34;: streamRpc.OrderRequest{OrderId: \u0026#34;201907310001\u0026#34;, TimeStamp: time.Now().Unix()}, \u0026#34;201907310002\u0026#34;: streamRpc.OrderRequest{OrderId: \u0026#34;201907310002\u0026#34;, TimeStamp: time.Now().Unix()}, } conn, err := grpc.Dial(\u0026#34;localhost:8081\u0026#34;, grpc.WithInsecure()) if err != nil{ panic(err) } defer conn.Close() client := streamRpc.NewOrderServiceClient(conn) stream, err := client.AddOrderList(context.Background()) //调用方法发送流数据 for _, info := range orderMap { err = stream.Send(\u0026amp;info) if err != nil { panic(err.Error()) } } for { orderInfo, err := stream.CloseAndRecv() if err == io.EOF { fmt.Println(\u0026#34; 读取数据结束了 \u0026#34;) return } if err != nil { fmt.Println(err.Error()) } fmt.Println(orderInfo.GetOrderStatus()) } } 这个交互类似于，服务器会通过recv接收然后进行业务处理，然后通过sendAndClose进行回传结果，client通过send发送流信息，然后通过CloseAndRecive接受消息。\n双向流模式 定义proto文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 syntax = \u0026#34;proto3\u0026#34;; option go_package=\u0026#34;./;streamRpc\u0026#34;; //订单请求参数 message OrderRequest { string orderId = 1; int64 timeStamp = 2; } //订单信息 message OrderInfo { string OrderId = 1; string OrderName = 2; string OrderStatus = 3; } //订单服务service定义 service OrderService { rpc GetOrderInfos (stream OrderRequest) returns (stream OrderInfo) {}; //双向流模式 } 客户端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type OrderService_GetOrderInfosClient interface { Send(*OrderRequest) error Recv() (*OrderInfo, error) grpc.ClientStream } type orderServiceGetOrderInfosClient struct { grpc.ClientStream } func (x *orderServiceGetOrderInfosClient) Send(m *OrderRequest) error { return x.ClientStream.SendMsg(m) } func (x *orderServiceGetOrderInfosClient) Recv() (*OrderInfo, error) { m := new(OrderInfo) if err := x.ClientStream.RecvMsg(m); err != nil { return nil, err } return m, nil } 服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type OrderService_GetOrderInfosServer interface { Send(*OrderInfo) error Recv() (*OrderRequest, error) grpc.ServerStream } type orderServiceGetOrderInfosServer struct { grpc.ServerStream } func (x *orderServiceGetOrderInfosServer) Send(m *OrderInfo) error { return x.ServerStream.SendMsg(m) } func (x *orderServiceGetOrderInfosServer) Recv() (*OrderRequest, error) { m := new(OrderRequest) if err := x.ServerStream.RecvMsg(m); err != nil { return nil, err } return m, nil } 可以发现无论是服务器还是客户端都增加了recv和send方法。\n服务器实现 参数是实现了recv和send的接口，可以发现recv和send都放到了同一个for中，如果读取结束自动break\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;goTrip/streamRpc\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net\u0026#34; ) type OrderServiceImpl struct { } //实现grpc双向流模式 func (os *OrderServiceImpl) GetOrderInfos(stream streamRpc.OrderService_GetOrderInfosServer) error { for { orderRequest, err := stream.Recv() if err == io.EOF { fmt.Println(\u0026#34; 数据读取结束 \u0026#34;) return err } if err != nil { panic(err.Error()) return err } fmt.Println(orderRequest.GetOrderId()) orderMap := map[string]streamRpc.OrderInfo{ \u0026#34;201907300001\u0026#34;: streamRpc.OrderInfo{OrderId: \u0026#34;201907300001\u0026#34;, OrderName: \u0026#34;衣服\u0026#34;, OrderStatus: \u0026#34;已付款\u0026#34;}, \u0026#34;201907310001\u0026#34;: streamRpc.OrderInfo{OrderId: \u0026#34;201907310001\u0026#34;, OrderName: \u0026#34;零食\u0026#34;, OrderStatus: \u0026#34;已付款\u0026#34;}, \u0026#34;201907310002\u0026#34;: streamRpc.OrderInfo{OrderId: \u0026#34;201907310002\u0026#34;, OrderName: \u0026#34;食品\u0026#34;, OrderStatus: \u0026#34;未付款\u0026#34;}, } result := orderMap[orderRequest.GetOrderId()] //发送数据 err = stream.Send(\u0026amp;result) if err == io.EOF { fmt.Println(err) return err } if err != nil { fmt.Println(err.Error()) return err } } return nil } func main() { server := grpc.NewServer() streamRpc.RegisterOrderServiceServer(server,new(OrderServiceImpl)) listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(nil) } server.Serve(listen) } 客户端实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;goTrip/streamRpc\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;io\u0026#34; ) func main() { //1、Dail连接 conn, err := grpc.Dial(\u0026#34;localhost:8081\u0026#34;, grpc.WithInsecure()) if err != nil { panic(err.Error()) } defer conn.Close() orderServiceClient := streamRpc.NewOrderServiceClient(conn) fmt.Println(\u0026#34;客户端请求RPC调用：双向流模式\u0026#34;) orderIDs := []string{\u0026#34;201907300001\u0026#34;, \u0026#34;201907310001\u0026#34;, \u0026#34;201907310002\u0026#34;} orderInfoClient, err := orderServiceClient.GetOrderInfos(context.Background()) for _, orderID := range orderIDs { orderRequest := streamRpc.OrderRequest{OrderId: orderID} err := orderInfoClient.Send(\u0026amp;orderRequest) if err != nil { panic(err.Error()) } } //关闭 orderInfoClient.CloseSend() for { orderInfo, err := orderInfoClient.Recv() if err == io.EOF { fmt.Println(\u0026#34;读取结束\u0026#34;) return } if err != nil { return } fmt.Println(\u0026#34;读取到的信息：\u0026#34;, orderInfo) } } grpc验证 gRPC中默认支持两种授权方式,分别是：SSL/TLS认证方式、基于Token的认证方式。\nSSL全称是Secure Sockets Layer，又被称之为安全套接字层，是一种标准安全协议，用于在通信过程中建立客户端与服务器之间的加密链接。 TLS的全称是Transport Layer Security，TLS是SSL的升级版。在使用的过程中，往往习惯于将SSL和TLS组合在一起写作SSL/TLS。 简而言之，SSL/TLS是一种用于网络通信中加密的安全协议。\n基于token 在gRPC中，允许开发者自定义自己的认证规则，通过\n1 func WithPerRPCCredentials(creds credentials.PerRPCCredentials) 可以看到我们需要实现一个PerRPCCredentials接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type PerRPCCredentials interface { // GetRequestMetadata gets the current request metadata, refreshing // tokens if required. This should be called by the transport layer on // each request, and the data should be populated in headers or other // context. If a status code is returned, it will be used as the status // for the RPC. uri is the URI of the entry point for the request. // When supported by the underlying implementation, ctx can be used for // timeout and cancellation. Additionally, RequestInfo data will be // available via ctx to this call. // TODO(zhaoq): Define the set of the qualified keys instead of leaving // it as an arbitrary string. GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) // RequireTransportSecurity indicates whether the credentials requires // transport security. RequireTransportSecurity() bool } 我们自己创建一个结构体实现一下吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package token import \u0026#34;context\u0026#34; type TokenAuthentication struct { ApiKey string ApiSecret string } //组织token信息 func (t *TokenAuthentication) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) { return map[string]string{ \u0026#34;apikey\u0026#34;: t.ApiKey, \u0026#34;apisecret\u0026#34;: t.ApiSecret, },nil } //是否基于TLS认证进行安全传输 func (t *TokenAuthentication) RequireTransportSecurity() bool{ return false } 以后客户端可以通过token来访问\n1 2 3 4 5 6 7 8 auth := TokenAuthentication{ ApiKey: \u0026#34;hello\u0026#34;, ApiSecret: \u0026#34;20190812\u0026#34;, } dial, err := grpc.Dial(\u0026#34;localhost:8081\u0026#34;, grpc.WithPerRPCCredentials(\u0026amp;auth)) if err != nil { panic(err.Error()) } 服务器 这里的服务器通过metadata.FromIncomingContext(ctx)，获得key，secret，然后进行校验。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;goTrip/rpcToken\u0026#34; \u0026#34;golang.org/x/net/context\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;google.golang.org/grpc/codes\u0026#34; \u0026#34;google.golang.org/grpc/metadata\u0026#34; \u0026#34;google.golang.org/grpc/status\u0026#34; \u0026#34;net\u0026#34; ) type MathManager struct { } func (mm *MathManager) AddMethod(ctx context.Context, request *rpcToken.RequestArgs) (response *rpcToken.Response, err error) { meta, exist := metadata.FromIncomingContext(ctx) if !exist{ return nil,status.Errorf(codes.Unauthenticated,\u0026#34;无token\u0026#34;) } var appKey string var appSecret string key,ok := meta[\u0026#34;apikey\u0026#34;] if ok{ appKey = key[0] } secret,ok := meta[\u0026#34;apisecret\u0026#34;] if ok{ appSecret = secret[0] } fmt.Println(appKey,appSecret) //控制token if appKey != \u0026#34;hello\u0026#34; || appSecret != \u0026#34;20190812\u0026#34; { return nil, status.Errorf(codes.Unauthenticated, \u0026#34;Token 不合法\u0026#34;) } fmt.Println(\u0026#34; 服务端 Add方法 \u0026#34;) result := request.Args1 + request.Args2 fmt.Println(\u0026#34; 计算结果是：\u0026#34;, result) response = new(rpcToken.Response) response.Code = 1; response.Message = \u0026#34;执行成功\u0026#34; return response, nil } func main() { server := grpc.NewServer() rpcToken.RegisterMathServiceServer(server,new(MathManager)) listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(err) } server.Serve(listen) } 客户端 要注意 grpc.Dial(\u0026ldquo;localhost:8081\u0026rdquo;, grpc.WithPerRPCCredentials(tk),grpc.WithInsecure())，如果只用token需要用grpc.WithInsecure()\n否则会报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;goTrip/rpcToken\u0026#34; \u0026#34;goTrip/rpcToken/token\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;log\u0026#34; ) func main() { tk := \u0026amp;token.TokenAuthentication{ ApiKey: \u0026#34;hello\u0026#34;, ApiSecret: \u0026#34;20190812\u0026#34;, } dial, err := grpc.Dial(\u0026#34;localhost:8081\u0026#34;, grpc.WithPerRPCCredentials(tk),grpc.WithInsecure()) if err != nil{ fmt.Println(err.Error()) log.Fatal(err.Error()) } client := rpcToken.NewMathServiceClient(dial) req := \u0026amp;rpcToken.RequestArgs{ Args1: 1, Args2: 2, } resp, err := client.AddMethod(context.Background(), req) if err != nil{ fmt.Println(err.Error()) log.Fatal(err.Error()) } fmt.Println(resp.GetCode(),resp.GetMessage()) } grpc拦截器 在上节课程中，我们学习使用了gRPC框架中的两种认证方式：TLS验证和Token验证。\n但是，在服务端的方法中，每个方法都要进行token的判断。程序效率太低，可以优化一下处理逻辑，在调用服务端的具体方法之前，先进行拦截，并进行token验证判断，这种方式称之为拦截器处理。\n除了此处的token验证判断处理以外，还可以进行日志处理等。\n使用拦截器，首先需要注册。在grpc中编程实现中，可以在NewSever时添加拦截器设置，grpc框架中可以通过UnaryInterceptor方法设置自定义的拦截器，并返回ServerOption。具体代码如下：\n1 grpc.UnaryInterceptor() 点进去发现需要一个函数\n1 type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error) 我们按自己的逻辑实现就好了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func TokenInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error){ //通过metadata md, exist := metadata.FromIncomingContext(ctx) if !exist { return nil, status.Errorf(codes.Unauthenticated, \u0026#34;无Token认证信息\u0026#34;) } var appKey string var appSecret string if key, ok := md[\u0026#34;apikey\u0026#34;]; ok { appKey = key[0] } if secret, ok := md[\u0026#34;apisecret\u0026#34;]; ok { appSecret = secret[0] } if appKey != \u0026#34;hello\u0026#34; || appSecret != \u0026#34;20190812\u0026#34; { return nil, status.Errorf(codes.Unauthenticated, \u0026#34;Token 不合法\u0026#34;) } //有点像java的doFilter，向下执行的意思 return handler(ctx,req) } 当然光写了拦截方法不行，我们得注册到服务器\n1 server := grpc.NewServer(grpc.UnaryInterceptor(TokenInterceptor)) 整体代码：\n服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;goTrip/rpcToken\u0026#34; \u0026#34;golang.org/x/net/context\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;google.golang.org/grpc/codes\u0026#34; \u0026#34;google.golang.org/grpc/metadata\u0026#34; \u0026#34;google.golang.org/grpc/status\u0026#34; \u0026#34;net\u0026#34; ) type MathManager struct { } func TokenInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error){ //通过metadata md, exist := metadata.FromIncomingContext(ctx) if !exist { return nil, status.Errorf(codes.Unauthenticated, \u0026#34;无Token认证信息\u0026#34;) } var appKey string var appSecret string if key, ok := md[\u0026#34;apikey\u0026#34;]; ok { appKey = key[0] } if secret, ok := md[\u0026#34;apisecret\u0026#34;]; ok { appSecret = secret[0] } if appKey != \u0026#34;hello\u0026#34; || appSecret != \u0026#34;20190812\u0026#34; { return nil, status.Errorf(codes.Unauthenticated, \u0026#34;Token 不合法\u0026#34;) } return handler(ctx,req) } func (mm *MathManager) AddMethod(ctx context.Context, request *rpcToken.RequestArgs) (response *rpcToken.Response, err error) { //meta, exist := metadata.FromIncomingContext(ctx) //if !exist{ // return nil,status.Errorf(codes.Unauthenticated,\u0026#34;无token\u0026#34;) //} //var appKey string //var appSecret string //key,ok := meta[\u0026#34;apikey\u0026#34;] //if ok{ // appKey = key[0] //} //secret,ok := meta[\u0026#34;apisecret\u0026#34;] //if ok{ // appSecret = secret[0] //} //fmt.Println(appKey,appSecret) ////控制token //if appKey != \u0026#34;hello\u0026#34; || appSecret != \u0026#34;20190812\u0026#34; { // return nil, status.Errorf(codes.Unauthenticated, \u0026#34;Token 不合法\u0026#34;) //} fmt.Println(\u0026#34; 服务端 Add方法 \u0026#34;) result := request.Args1 + request.Args2 fmt.Println(\u0026#34; 计算结果是：\u0026#34;, result) response = new(rpcToken.Response) response.Code = 1; response.Message = \u0026#34;执行成功\u0026#34; return response, nil } func main() { server := grpc.NewServer(grpc.UnaryInterceptor(TokenInterceptor)) rpcToken.RegisterMathServiceServer(server,new(MathManager)) listen, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8081\u0026#34;) if err != nil{ panic(err) } server.Serve(listen) } 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;goTrip/rpcToken\u0026#34; \u0026#34;goTrip/rpcToken/token\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;log\u0026#34; ) func main() { tk := \u0026amp;token.TokenAuthentication{ ApiKey: \u0026#34;hello\u0026#34;, ApiSecret: \u0026#34;20190812\u0026#34;, } dial, err := grpc.Dial(\u0026#34;localhost:8081\u0026#34;, grpc.WithPerRPCCredentials(tk),grpc.WithInsecure()) if err != nil{ fmt.Println(err.Error()) log.Fatal(err.Error()) } client := rpcToken.NewMathServiceClient(dial) req := \u0026amp;rpcToken.RequestArgs{ Args1: 1, Args2: 2, } resp, err := client.AddMethod(context.Background(), req) if err != nil{ fmt.Println(err.Error()) log.Fatal(err.Error()) } fmt.Println(resp.GetCode(),resp.GetMessage()) } ​\n","date":"2023-01-06T00:00:00Z","image":"https://wolvestorm.github.io/blog/posts/golang/grpc_hu1eee0aeb00d0db40f03f5ec8233f4563_83469_120x120_fill_q75_box_smart1.jpeg","permalink":"https://wolvestorm.github.io/blog/posts/golang/","title":"GRPC"},{"content":"Gin gin框架路由详解 gin框架使用的是定制版本的httprouter，其路由的原理是大量使用公共前缀的树结构，它基本上是一个紧凑的Trie tree（或者只是Radix Tree）。具有公共前缀的节点也共享一个公共父节点。\nRadix Tree 基数树（Radix Tree）又称为PAT位树（Patricia Trie or crit bit tree），是一种更节省空间的前缀树（Trie Tree）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。下图为一个基数树示例：\nRadix Tree可以被认为是一棵简洁版的前缀树。我们注册路由的过程就是构造前缀树的过程，具有公共前缀的节点也共享一个公共父节点。假设我们现在注册有以下路由信息：\n1 2 3 4 5 6 7 8 9 10 r := gin.Default() r.GET(\u0026#34;/\u0026#34;, func1) r.GET(\u0026#34;/search/\u0026#34;, func2) r.GET(\u0026#34;/support/\u0026#34;, func3) r.GET(\u0026#34;/blog/\u0026#34;, func4) r.GET(\u0026#34;/blog/:post/\u0026#34;, func5) r.GET(\u0026#34;/about-us/\u0026#34;, func6) r.GET(\u0026#34;/about-us/team/\u0026#34;, func7) r.GET(\u0026#34;/contact/\u0026#34;, func8) 那么我们会得到一个GET方法对应的路由树，具体结构如下：\n1 2 3 4 5 6 7 8 9 10 11 Priority Path Handle 9 \\ *\u0026lt;1\u0026gt; 3 ├s nil 2 |├earch\\ *\u0026lt;2\u0026gt; 1 |└upport\\ *\u0026lt;3\u0026gt; 2 ├blog\\ *\u0026lt;4\u0026gt; 1 | └:post nil 1 | └\\ *\u0026lt;5\u0026gt; 2 ├about-us\\ *\u0026lt;6\u0026gt; 1 | └team\\ *\u0026lt;7\u0026gt; 1 └contact\\ *\u0026lt;8\u0026gt; 上面最右边那一列每个*\u0026lt;数字\u0026gt;表示Handle处理函数的内存地址(一个指针)。从根节点遍历到叶子节点我们就能得到完整的路由表。\n例如：blog/:post其中:post只是实际文章名称的占位符(参数)。与hash-maps不同，这种树结构还允许我们使用像:post参数这种动态部分，因为我们实际上是根据路由模式进行匹配，而不仅仅是比较哈希值。\n由于URL路径具有层次结构，并且只使用有限的一组字符(字节值)，所以很可能有许多常见的前缀。这使我们可以很容易地将路由简化为更小的问题。此外，路由器为每种请求方法管理一棵单独的树。一方面，它比在每个节点中都保存一个method-\u0026gt; handle map更加节省空间，它还使我们甚至可以在开始在前缀树中查找之前大大减少路由问题。\n为了获得更好的可伸缩性，每个树级别上的子节点都按Priority(优先级)排序，其中优先级（最左列）就是在子节点(子节点、子子节点等等)中注册的句柄的数量。这样做有两个好处:\n首先优先匹配被大多数路由路径包含的节点。这样可以让尽可能多的路由快速被定位。 类似于成本补偿。最长的路径可以被优先匹配，补偿体现在最长的路径需要花费更长的时间来定位，如果最长路径的节点能被优先匹配（即每次拿子节点都命中），那么路由匹配所花的时间不一定比短路径的路由长。下面展示了节点（每个-可以看做一个节点）匹配的路径：从左到右，从上到下。 1 2 3 4 5 6 7 ├------------ ├--------- ├----- ├---- ├-- ├-- └- 路由树节点 路由树是由一个个节点构成的，gin框架路由树的节点由node结构体表示，它有以下字段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // tree.go type node struct { // 节点路径，比如上面的s，earch，和upport path string // 和children字段对应, 保存的是分裂的分支的第一个字符 // 例如search和support, 那么s节点的indices对应的\u0026#34;eu\u0026#34; // 代表有两个分支, 分支的首字母分别是e和u indices string // 儿子节点 children []*node // 处理函数链条（切片） handlers HandlersChain // 优先级，子节点、子子节点等注册的handler数量 priority uint32 // 节点类型，包括static, root, param, catchAll // static: 静态节点（默认），比如上面的s，earch等节点 // root: 树的根节点 // catchAll: 有*匹配的节点 // param: 参数节点 nType nodeType // 路径上最大参数个数 maxParams uint8 // 节点是否是参数节点，比如上面的:post wildChild bool // 完整路径 fullPath string } 请求方法树 在gin的路由中，每一个HTTP Method(GET、POST、PUT、DELETE…)都对应了一棵 radix tree，我们注册路由的时候会调用下面的addRoute函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // gin.go func (engine *Engine) addRoute(method, path string, handlers HandlersChain) { // liwenzhou.com... // 获取请求方法对应的树 root := engine.trees.get(method) if root == nil { // 如果没有就创建一个 root = new(node) root.fullPath = \u0026#34;/\u0026#34; engine.trees = append(engine.trees, methodTree{method: method, root: root}) } root.addRoute(path, handlers) } 从上面的代码中我们可以看到在注册路由的时候都是先根据请求方法获取对应的树，也就是gin框架会为每一个请求方法创建一棵对应的树。只不过需要注意到一个细节是gin框架中保存请求方法对应树关系并不是使用的map而是使用的切片，engine.trees的类型是methodTrees，其定义如下：\n1 2 3 4 5 6 type methodTree struct { method string root *node } type methodTrees []methodTree // slice 而获取请求方法对应树的get方法定义如下：\n1 2 3 4 5 6 7 8 func (trees methodTrees) get(method string) *node { for _, tree := range trees { if tree.method == method { return tree.root } } return nil } 为什么使用切片而不是map来存储请求方法-\u0026gt;树的结构呢？我猜是出于节省内存的考虑吧，毕竟HTTP请求方法的数量是固定的，而且常用的就那几种，所以即使使用切片存储查询起来效率也足够了。顺着这个思路，我们可以看一下gin框架中engine的初始化方法中，确实对tress字段做了一次内存申请：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func New() *Engine { debugPrintWARNINGNew() engine := \u0026amp;Engine{ RouterGroup: RouterGroup{ Handlers: nil, basePath: \u0026#34;/\u0026#34;, root: true, }, // liwenzhou.com ... // 初始化容量为9的切片（HTTP1.1请求方法共9种） trees: make(methodTrees, 0, 9), // liwenzhou.com... } engine.RouterGroup.engine = engine engine.pool.New = func() interface{} { return engine.allocateContext() } return engine } 注册路由 注册路由的逻辑主要有addRoute函数和insertChild方法。\naddRoute 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 // tree.go // addRoute 将具有给定句柄的节点添加到路径中。 // 不是并发安全的 func (n *node) addRoute(path string, handlers HandlersChain) { fullPath := path n.priority++ numParams := countParams(path) // 数一下参数个数 // 空树就直接插入当前节点 if len(n.path) == 0 \u0026amp;\u0026amp; len(n.children) == 0 { n.insertChild(numParams, path, fullPath, handlers) n.nType = root return } parentFullPathIndex := 0 walk: for { // 更新当前节点的最大参数个数 if numParams \u0026gt; n.maxParams { n.maxParams = numParams } // 找到最长的通用前缀 // 这也意味着公共前缀不包含“:”\u0026#34;或“*” / // 因为现有键不能包含这些字符。 i := longestCommonPrefix(path, n.path) // 分裂边缘（此处分裂的是当前树节点） // 例如一开始path是search，新加入support，s是他们通用的最长前缀部分 // 那么会将s拿出来作为parent节点，增加earch和upport作为child节点 if i \u0026lt; len(n.path) { child := node{ path: n.path[i:], // 公共前缀后的部分作为子节点 wildChild: n.wildChild, indices: n.indices, children: n.children, handlers: n.handlers, priority: n.priority - 1, //子节点优先级-1 fullPath: n.fullPath, } // Update maxParams (max of all children) for _, v := range child.children { if v.maxParams \u0026gt; child.maxParams { child.maxParams = v.maxParams } } n.children = []*node{\u0026amp;child} // []byte for proper unicode char conversion, see #65 n.indices = string([]byte{n.path[i]}) n.path = path[:i] n.handlers = nil n.wildChild = false n.fullPath = fullPath[:parentFullPathIndex+i] } // 将新来的节点插入新的parent节点作为子节点 if i \u0026lt; len(path) { path = path[i:] if n.wildChild { // 如果是参数节点 parentFullPathIndex += len(n.path) n = n.children[0] n.priority++ // Update maxParams of the child node if numParams \u0026gt; n.maxParams { n.maxParams = numParams } numParams-- // 检查通配符是否匹配 if len(path) \u0026gt;= len(n.path) \u0026amp;\u0026amp; n.path == path[:len(n.path)] { // 检查更长的通配符, 例如 :name and :names if len(n.path) \u0026gt;= len(path) || path[len(n.path)] == \u0026#39;/\u0026#39; { continue walk } } pathSeg := path if n.nType != catchAll { pathSeg = strings.SplitN(path, \u0026#34;/\u0026#34;, 2)[0] } prefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path panic(\u0026#34;\u0026#39;\u0026#34; + pathSeg + \u0026#34;\u0026#39; in new path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39; conflicts with existing wildcard \u0026#39;\u0026#34; + n.path + \u0026#34;\u0026#39; in existing prefix \u0026#39;\u0026#34; + prefix + \u0026#34;\u0026#39;\u0026#34;) } // 取path首字母，用来与indices做比较 c := path[0] // 处理参数后加斜线情况 if n.nType == param \u0026amp;\u0026amp; c == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; len(n.children) == 1 { parentFullPathIndex += len(n.path) n = n.children[0] n.priority++ continue walk } // 检查路path下一个字节的子节点是否存在 // 比如s的子节点现在是earch和upport，indices为eu // 如果新加一个路由为super，那么就是和upport有匹配的部分u，将继续分列现在的upport节点 for i, max := 0, len(n.indices); i \u0026lt; max; i++ { if c == n.indices[i] { parentFullPathIndex += len(n.path) i = n.incrementChildPrio(i) n = n.children[i] continue walk } } // 否则就插入 if c != \u0026#39;:\u0026#39; \u0026amp;\u0026amp; c != \u0026#39;*\u0026#39; { // []byte for proper unicode char conversion, see #65 // 注意这里是直接拼接第一个字符到n.indices n.indices += string([]byte{c}) child := \u0026amp;node{ maxParams: numParams, fullPath: fullPath, } // 追加子节点 n.children = append(n.children, child) n.incrementChildPrio(len(n.indices) - 1) n = child } n.insertChild(numParams, path, fullPath, handlers) return } // 已经注册过的节点 if n.handlers != nil { panic(\u0026#34;handlers are already registered for path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } n.handlers = handlers return } } 其实上面的代码很好理解，大家可以参照动画尝试将以下情形代入上面的代码逻辑，体味整个路由树构造的详细过程：\n第一次注册路由，例如注册search 继续注册一条没有公共前缀的路由，例如blog 注册一条与先前注册的路由有公共前缀的路由，例如support insertChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 // tree.go func (n *node) insertChild(numParams uint8, path string, fullPath string, handlers HandlersChain) { // 找到所有的参数 for numParams \u0026gt; 0 { // 查找前缀直到第一个通配符 wildcard, i, valid := findWildcard(path) if i \u0026lt; 0 { // 没有发现通配符 break } // 通配符的名称必须包含\u0026#39;:\u0026#39; 和 \u0026#39;*\u0026#39; if !valid { panic(\u0026#34;only one wildcard per path segment is allowed, has: \u0026#39;\u0026#34; + wildcard + \u0026#34;\u0026#39; in path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } // 检查通配符是否有名称 if len(wildcard) \u0026lt; 2 { panic(\u0026#34;wildcards must be named with a non-empty name in path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } // 检查这个节点是否有已经存在的子节点 // 如果我们在这里插入通配符，这些子节点将无法访问 if len(n.children) \u0026gt; 0 { panic(\u0026#34;wildcard segment \u0026#39;\u0026#34; + wildcard + \u0026#34;\u0026#39; conflicts with existing children in path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } if wildcard[0] == \u0026#39;:\u0026#39; { // param if i \u0026gt; 0 { // 在当前通配符之前插入前缀 n.path = path[:i] path = path[i:] } n.wildChild = true child := \u0026amp;node{ nType: param, path: wildcard, maxParams: numParams, fullPath: fullPath, } n.children = []*node{child} n = child n.priority++ numParams-- // 如果路径没有以通配符结束 // 那么将有另一个以\u0026#39;/\u0026#39;开始的非通配符子路径。 if len(wildcard) \u0026lt; len(path) { path = path[len(wildcard):] child := \u0026amp;node{ maxParams: numParams, priority: 1, fullPath: fullPath, } n.children = []*node{child} n = child // 继续下一轮循环 continue } // 否则我们就完成了。将处理函数插入新叶子中 n.handlers = handlers return } // catchAll if i+len(wildcard) != len(path) || numParams \u0026gt; 1 { panic(\u0026#34;catch-all routes are only allowed at the end of the path in path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } if len(n.path) \u0026gt; 0 \u0026amp;\u0026amp; n.path[len(n.path)-1] == \u0026#39;/\u0026#39; { panic(\u0026#34;catch-all conflicts with existing handle for the path segment root in path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } // currently fixed width 1 for \u0026#39;/\u0026#39; i-- if path[i] != \u0026#39;/\u0026#39; { panic(\u0026#34;no / before catch-all in path \u0026#39;\u0026#34; + fullPath + \u0026#34;\u0026#39;\u0026#34;) } n.path = path[:i] // 第一个节点:路径为空的catchAll节点 child := \u0026amp;node{ wildChild: true, nType: catchAll, maxParams: 1, fullPath: fullPath, } // 更新父节点的maxParams if n.maxParams \u0026lt; 1 { n.maxParams = 1 } n.children = []*node{child} n.indices = string(\u0026#39;/\u0026#39;) n = child n.priority++ // 第二个节点:保存变量的节点 child = \u0026amp;node{ path: path[i:], nType: catchAll, maxParams: 1, handlers: handlers, priority: 1, fullPath: fullPath, } n.children = []*node{child} return } // 如果没有找到通配符，只需插入路径和句柄 n.path = path n.handlers = handlers n.fullPath = fullPath } insertChild函数是根据path本身进行分割，将/分开的部分分别作为节点保存，形成一棵树结构。参数匹配中的:和*的区别是，前者是匹配一个字段而后者是匹配后面所有的路径。\n路由匹配 我们先来看gin框架处理请求的入口函数ServeHTTP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // gin.go func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) { // 这里使用了对象池 c := engine.pool.Get().(*Context) // 这里有一个细节就是Get对象后做初始化 c.writermem.reset(w) c.Request = req c.reset() engine.handleHTTPRequest(c) // 我们要找的处理HTTP请求的函数 engine.pool.Put(c) // 处理完请求后将对象放回池子 } 函数很长，这里省略了部分代码，只保留相关逻辑代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // gin.go func (engine *Engine) handleHTTPRequest(c *Context) { // liwenzhou.com... // 根据请求方法找到对应的路由树 t := engine.trees for i, tl := 0, len(t); i \u0026lt; tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // 在路由树中根据path查找 value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 执行函数链条 c.writermem.WriteHeaderNow() return } // liwenzhou.com... c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body) } 路由匹配是由节点的 getValue方法实现的。getValue根据给定的路径(键)返回nodeValue值，保存注册的处理函数和匹配到的路径参数数据。\n如果找不到任何处理函数，则会尝试TSR(尾随斜杠重定向)。\n代码虽然很长，但还算比较工整。大家可以借助注释看一下路由查找及参数匹配的逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 // tree.go type nodeValue struct { handlers HandlersChain params Params // []Param tsr bool fullPath string } // liwenzhou.com... func (n *node) getValue(path string, po Params, unescape bool) (value nodeValue) { value.params = po walk: // Outer loop for walking the tree for { prefix := n.path if path == prefix { // 我们应该已经到达包含处理函数的节点。 // 检查该节点是否注册有处理函数 if value.handlers = n.handlers; value.handlers != nil { value.fullPath = n.fullPath return } if path == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; n.wildChild \u0026amp;\u0026amp; n.nType != root { value.tsr = true return } // 没有找到处理函数 检查这个路径末尾+/ 是否存在注册函数 indices := n.indices for i, max := 0, len(indices); i \u0026lt; max; i++ { if indices[i] == \u0026#39;/\u0026#39; { n = n.children[i] value.tsr = (len(n.path) == 1 \u0026amp;\u0026amp; n.handlers != nil) || (n.nType == catchAll \u0026amp;\u0026amp; n.children[0].handlers != nil) return } } return } if len(path) \u0026gt; len(prefix) \u0026amp;\u0026amp; path[:len(prefix)] == prefix { path = path[len(prefix):] // 如果该节点没有通配符(param或catchAll)子节点 // 我们可以继续查找下一个子节点 if !n.wildChild { c := path[0] indices := n.indices for i, max := 0, len(indices); i \u0026lt; max; i++ { if c == indices[i] { n = n.children[i] // 遍历树 continue walk } } // 没找到 // 如果存在一个相同的URL但没有末尾/的叶子节点 // 我们可以建议重定向到那里 value.tsr = path == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; n.handlers != nil return } // 根据节点类型处理通配符子节点 n = n.children[0] switch n.nType { case param: // find param end (either \u0026#39;/\u0026#39; or path end) end := 0 for end \u0026lt; len(path) \u0026amp;\u0026amp; path[end] != \u0026#39;/\u0026#39; { end++ } // 保存通配符的值 if cap(value.params) \u0026lt; int(n.maxParams) { value.params = make(Params, 0, n.maxParams) } i := len(value.params) value.params = value.params[:i+1] // 在预先分配的容量内扩展slice value.params[i].Key = n.path[1:] val := path[:end] if unescape { var err error if value.params[i].Value, err = url.QueryUnescape(val); err != nil { value.params[i].Value = val // fallback, in case of error } } else { value.params[i].Value = val } // 继续向下查询 if end \u0026lt; len(path) { if len(n.children) \u0026gt; 0 { path = path[end:] n = n.children[0] continue walk } // ... but we can\u0026#39;t value.tsr = len(path) == end+1 return } if value.handlers = n.handlers; value.handlers != nil { value.fullPath = n.fullPath return } if len(n.children) == 1 { // 没有找到处理函数. 检查此路径末尾加/的路由是否存在注册函数 // 用于 TSR 推荐 n = n.children[0] value.tsr = n.path == \u0026#34;/\u0026#34; \u0026amp;\u0026amp; n.handlers != nil } return case catchAll: // 保存通配符的值 if cap(value.params) \u0026lt; int(n.maxParams) { value.params = make(Params, 0, n.maxParams) } i := len(value.params) value.params = value.params[:i+1] // 在预先分配的容量内扩展slice value.params[i].Key = n.path[2:] if unescape { var err error if value.params[i].Value, err = url.QueryUnescape(path); err != nil { value.params[i].Value = path // fallback, in case of error } } else { value.params[i].Value = path } value.handlers = n.handlers value.fullPath = n.fullPath return default: panic(\u0026#34;invalid node type\u0026#34;) } } // 找不到，如果存在一个在当前路径最后添加/的路由 // 我们会建议重定向到那里 value.tsr = (path == \u0026#34;/\u0026#34;) || (len(prefix) == len(path)+1 \u0026amp;\u0026amp; prefix[len(path)] == \u0026#39;/\u0026#39; \u0026amp;\u0026amp; path == prefix[:len(prefix)-1] \u0026amp;\u0026amp; n.handlers != nil) return } } gin框架中间件详解 gin框架涉及中间件相关有4个常用的方法，它们分别是c.Next()、c.Abort()、c.Set()、c.Get()。\n中间件的注册 gin框架中的中间件设计很巧妙，我们可以首先从我们最常用的r := gin.Default()的Default函数开始看，它内部构造一个新的engine之后就通过Use()函数注册了Logger中间件和Recovery中间件：\n1 2 3 4 5 6 func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) // 默认注册的两个中间件 return engine } 继续往下查看一下Use()函数的代码：\n1 2 3 4 5 6 func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes { engine.RouterGroup.Use(middleware...) // 实际上还是调用的RouterGroup的Use函数 engine.rebuild404Handlers() engine.rebuild405Handlers() return engine } 从下方的代码可以看出，注册中间件其实就是将中间件函数追加到group.Handlers中：\n1 2 3 4 func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } 而我们注册路由时会将对应路由的函数和之前的中间件函数结合到一起：\n1 2 3 4 5 6 func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) // 将处理请求的函数与中间件函数结合 group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj() } 其中结合操作的函数内容如下，注意观察这里是如何实现拼接两个切片得到一个新切片的。\n1 2 3 4 5 6 7 8 9 10 11 12 const abortIndex int8 = math.MaxInt8 / 2 func (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain { finalSize := len(group.Handlers) + len(handlers) if finalSize \u0026gt;= int(abortIndex) { // 这里有一个最大限制 panic(\u0026#34;too many handlers\u0026#34;) } mergedHandlers := make(HandlersChain, finalSize) copy(mergedHandlers, group.Handlers) copy(mergedHandlers[len(group.Handlers):], handlers) return mergedHandlers } 也就是说，我们会将一个路由的中间件函数和处理函数结合到一起组成一条处理函数链条HandlersChain，而它本质上就是一个由HandlerFunc组成的切片：\n1 type HandlersChain []HandlerFunc 中间件的执行 我们在上面路由匹配的时候见过如下逻辑：\n1 2 3 4 5 6 7 8 9 value := root.getValue(rPath, c.Params, unescape) if value.handlers != nil { c.handlers = value.handlers c.Params = value.params c.fullPath = value.fullPath c.Next() // 执行函数链条 c.writermem.WriteHeaderNow() return } 其中c.Next()就是很关键的一步，它的代码很简单：\n1 2 3 4 5 6 7 func (c *Context) Next() { c.index++ for c.index \u0026lt; int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ } } 从上面的代码可以看到，这里通过索引遍历HandlersChain链条，从而实现依次调用该路由的每一个函数（中间件或处理请求的函数）。\n我们可以在中间件函数中通过再次调用c.Next()实现嵌套调用（func1中调用func2；func2中调用func3），\n或者通过调用c.Abort()中断整个调用链条，从当前函数返回。\n1 2 3 func (c *Context) Abort() { c.index = abortIndex // 直接将索引置为最大限制值，从而退出循环 } c.Set()/c.Get() c.Set()和c.Get()这两个方法多用于在多个函数之间通过c传递数据的，比如我们可以在认证中间件中获取当前请求的相关信息（userID等）通过c.Set()存入c，然后在后续处理业务逻辑的函数中通过c.Get()来获取当前请求的用户。c就像是一根绳子，将该次请求相关的所有的函数都串起来了。\n总结 gin框架路由使用前缀树，路由注册的过程是构造前缀树的过程，路由匹配的过程就是查找前缀树的过程。 gin框架的中间件函数和处理函数是以切片形式的调用链条存在的，我们可以顺序调用也可以借助c.Next()方法实现嵌套调用。 借助c.Set()和c.Get()方法我们能够在不同的中间件函数中传递数据。 Gin连接mysql 驱动依赖\ngo get -u github.com/go-sql-driver/mysql\n如何使用\n里面的user password可改\n注意defer得卸载err的下面，不可以写成这样\n为什么不能写在这个位置？\n因为如果出错了，我们获得的open会是一个nil，在最后调用他的close，会出现空指针异常。\n所以我们应该在判断当err == nil才去关闭数据库。\nOpen函数实际上只是验证dsn参数是否正确，并不是真正和数据库连接。如果要检查数据源的名字是否有效，应该调用ping方法。\n当然一般不可能写在main函数里面，一般应该使模块化的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var db *sql.DB //这里用了一个匿名参数，我们可以不用在函数中声明err，但是会自己返回这个err参数。非常的优雅。 func initMysql() (err error) { dsn := \u0026#34;root:abc123456@tcp(127.0.0.1:3306)/go\u0026#34; db, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) //这里就不能用 := 因为db是公共变量 if err != nil { panic(err) } err = db.Ping() if err != nil { fmt.Printf(\u0026#34;connect fail , err : %v\\n\u0026#34;, err) panic(err) } fmt.Printf(\u0026#34;connect successful\u0026#34;) return } func main() { if err := initMysql();err!=nil{ fmt.Printf(\u0026#34;connect fail\u0026#34;) } defer db.Close() } 两个常用配置\nSetMaxOpenCoons()\t设置和mysql的最大连接数\nSetMaxIdleCoons()\t设置连接池的最大空闲连接数\n浅浅的研究一下源码 看一看驱动里面的源码\ninit方法\n点进去Regist\n此时可以发现是跳到了内置的标准库database里面\n在源码中，regist的是map中的值，比如map[\u0026ldquo;mysql\u0026rdquo;] = 驱动\n看一看open函数里做了什么事情\n可以发现我们是调用的openDB函数，返回的一个DB，有一些基本信息\n我们的用户名，密码都在c里面\n增删改查 queryRow（查询一列） 1 2 3 4 5 6 7 8 9 10 func queryRowDemo() { sql := \u0026#34;select id,name,age from test_user where id = ?\u0026#34; var u user err := db.QueryRow(sql, 1).Scan(\u0026amp;u.id, \u0026amp;u.name, \u0026amp;u.age) if err != nil { fmt.Printf(\u0026#34;scan failed , err : %v\u0026#34;, err) return } fmt.Printf(\u0026#34;id: %v,name: %v,age: %v\u0026#34;, u.id, u.name, u.age) } 这边值得注意的是，在调用了queryRow之后一定要调用scan，不然不会释放连接。\nquery（查询多行） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func queryMultiRowDemo() { sql := \u0026#34;select id,name,age from test_user where id \u0026gt; ? \u0026#34; query, err := db.Query(sql, 0) if err != nil { fmt.Printf(\u0026#34;query failed err: %v\\n\u0026#34;, err) return } defer query.Close()//这里需要关闭 for query.Next() { var u user err = query.Scan(\u0026amp;u.id, \u0026amp;u.name, \u0026amp;u.age) if err != nil { fmt.Printf(\u0026#34;scan failed err: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;id: %d,name: %s,age: %d\\n\u0026#34;, u.id, u.name, u.age) } } 为什么在中间需要close？不是在for中调用了scan，scan应该可以帮我们close嘛？因为不一定能够进去for循环。得手动调用close。\nexec（插入和更新和删除） 插入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func insertRowDemo() { sql := \u0026#34;insert into test_user(name,age)values(?,?)\u0026#34; exec, err := db.Exec(sql, \u0026#34;peter\u0026#34;, 99) if err != nil { fmt.Printf(\u0026#34;insert failed err: %v\\n\u0026#34;, err) return } id, err := exec.LastInsertId() //可以获得新插入的id if err != nil { fmt.Printf(\u0026#34;get id failed err: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;insert success last id is %d \\n\u0026#34;, id) } 更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func updateRowDemo() { sql := \u0026#34;update test_user set name = ? where id = ?\u0026#34; exec, err := db.Exec(sql, \u0026#34;john\u0026#34;, 3) if err != nil { fmt.Printf(\u0026#34;update failed err: %v\\n\u0026#34;, err) return } id, err := exec.RowsAffected() //可以影响的行数 if err != nil { fmt.Printf(\u0026#34;get row count failed err: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;update success row count is %d \\n\u0026#34;, id) } 删除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func deleteRowDemo() { sql := \u0026#34;delete from test_user where id = ?\u0026#34; exec, err := db.Exec(sql, 3) if err != nil { fmt.Printf(\u0026#34;delete failed err: %v\\n\u0026#34;, err) return } id, err := exec.RowsAffected() //可以影响的行数 if err != nil { fmt.Printf(\u0026#34;get row count failed err: %v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;delete success row count is %d \\n\u0026#34;, id) } Mysql预处理与Sql注入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func prepareDemo() { sql := \u0026#34;select id,name,age from test_user where id \u0026gt; ?\u0026#34; prepare, err := db.Prepare(sql) if err != nil { fmt.Printf(\u0026#34;prepare failed err: %v\\n\u0026#34;, err) } defer prepare.Close() query, err := prepare.Query(0) if err != nil { fmt.Printf(\u0026#34;query failed err: %v\\n\u0026#34;, err) } for query.Next() { var u user err = query.Scan(\u0026amp;u.id, \u0026amp;u.name, \u0026amp;u.age) if err != nil { fmt.Printf(\u0026#34;scan failed err: %v\\n\u0026#34;, err) } fmt.Printf(\u0026#34;id: %d,name: %s,age: %d\\n\u0026#34;, u.id, u.name, u.age) } } sql注入 试试sql注入吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func sqlInjection(name string) { sql := fmt.Sprintf(\u0026#34;select id,name,age from test_user where name = %s\u0026#34;, name) fmt.Println(sql) query, err := db.Query(sql) if err != nil { fmt.Printf(\u0026#34;scan failed err: %v\\n\u0026#34;, err) return } for query.Next() { var u user err = query.Scan(\u0026amp;u.id, \u0026amp;u.name, \u0026amp;u.age) if err != nil { fmt.Printf(\u0026#34;scan failed err: %v\\n\u0026#34;, err) } fmt.Printf(\u0026#34;id: %d,name: %s,age: %d\\n\u0026#34;, u.id, u.name, u.age) } } Mysql的事务 sqlX 强大的工具 安装\ngo get github.com/jmoiron/sqlx\n连接 1 2 3 4 5 6 7 8 9 10 11 12 13 var db1 *sqlx.DB func initDB() (err error) { dsn := \u0026#34;root:abc123456@tcp(127.0.0.1:3306)/go\u0026#34; db1, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, dsn) if err != nil { fmt.Printf(\u0026#34;err : %v\\n\u0026#34;, err) return } db.SetMaxOpenConns(200) db.SetMaxIdleConns(10) return } SQLX的基本使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type user1 struct { Id int `db:\u0026#34;id\u0026#34;` Name string `db:\u0026#34;name\u0026#34;` Age int `db:\u0026#34;age\u0026#34;` } func queryRowDemo1() { sql := \u0026#34;select id,name,age from test_user where id = ?\u0026#34; var u user1 err := db1.Get(\u0026amp;u, sql, 1) if err != nil { fmt.Printf(\u0026#34;get failed err: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;id: %v,name: %v,age: %v\u0026#34;, u.Id, u.Name, u.Age) } 注意结构体的值不可以写为小写，db1的get会通过反射给对象的属性赋值。如果为小写的话其他的包访问不到。\n查询多个\n1 2 3 4 5 6 7 8 9 10 11 func queryRowMultiDemo1() { sql := \u0026#34;select id,name,age from test_user where id \u0026gt; ?\u0026#34; var u []user1 err := db1.Select(\u0026amp;u, sql, 0) if err != nil { fmt.Printf(\u0026#34;get failed err: %v\u0026#34;, err) return } fmt.Printf(\u0026#34;users:%v\u0026#34;, u) } 增删改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 插入数据 func insertRowDemo() { sqlStr := \u0026#34;insert into user(name, age) values (?,?)\u0026#34; ret, err := db.Exec(sqlStr, \u0026#34;沙河小王子\u0026#34;, 19) if err != nil { fmt.Printf(\u0026#34;insert failed, err:%v\\n\u0026#34;, err) return } theID, err := ret.LastInsertId() // 新插入数据的id if err != nil { fmt.Printf(\u0026#34;get lastinsert ID failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;insert success, the id is %d.\\n\u0026#34;, theID) } // 更新数据 func updateRowDemo() { sqlStr := \u0026#34;update user set age=? where id = ?\u0026#34; ret, err := db.Exec(sqlStr, 39, 6) if err != nil { fmt.Printf(\u0026#34;update failed, err:%v\\n\u0026#34;, err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\u0026#34;get RowsAffected failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;update success, affected rows:%d\\n\u0026#34;, n) } // 删除数据 func deleteRowDemo() { sqlStr := \u0026#34;delete from user where id = ?\u0026#34; ret, err := db.Exec(sqlStr, 6) if err != nil { fmt.Printf(\u0026#34;delete failed, err:%v\\n\u0026#34;, err) return } n, err := ret.RowsAffected() // 操作影响的行数 if err != nil { fmt.Printf(\u0026#34;get RowsAffected failed, err:%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;delete success, affected rows:%d\\n\u0026#34;, n) } go-redis 1 go get -u github.com/go-redis/redis 连接redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func initRedis() (err error) { rdb = redis.NewClient( \u0026amp;redis.Options{ Addr: \u0026#34;localhost:6379\u0026#34;, Password: \u0026#34;abc123456\u0026#34;, DB: 0, PoolSize: 100, //连接池大小 }) _, err = rdb.Ping().Result() if err != nil { return err } return nil } func main() { if err := initRedis(); err != nil { fmt.Printf(\u0026#34;err : %v\u0026#34;, err) return } fmt.Printf(\u0026#34;connect success\\n\u0026#34;) } 连接哨兵模式 基本使用 get/set\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func redisDemo() { err := rdb.Set(\u0026#34;score\u0026#34;, 100, 1).Err() if err != nil { fmt.Printf(\u0026#34;set error err:%v\\n\u0026#34;, err) } result, err := rdb.Get(\u0026#34;score\u0026#34;).Result() if err != nil { fmt.Printf(\u0026#34;get error err:%v\\n\u0026#34;, err) return } fmt.Println(result) s, err := rdb.Get(\u0026#34;token\u0026#34;).Result() //优先判断错误是不是属于redis没有对应的key if err == redis.Nil { fmt.Printf(\u0026#34;the key is not exist\\n\u0026#34;) return } else if err != nil { fmt.Printf(\u0026#34;err : %v\u0026#34;, err) return } else { fmt.Printf(\u0026#34;%s\\n\u0026#34;, s) } } hset,hmset,hget\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func hgetDemo() (err error) { rdb.HMSet(\u0026#34;school\u0026#34;, map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;scuec\u0026#34;, \u0026#34;addr\u0026#34;: \u0026#34;laofang\u0026#34;, \u0026#34;isLike\u0026#34;: false, }) err = rdb.HSet(\u0026#34;user\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;phm\u0026#34;).Err() err = rdb.HSet(\u0026#34;user\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;1\u0026#34;).Err() if err != nil { fmt.Printf(\u0026#34;err :%v\\n\u0026#34;, err) return } //得到全部字段 result, err := rdb.HGetAll(\u0026#34;user\u0026#34;).Result() if err == redis.Nil { fmt.Printf(\u0026#34;err: %v\\n\u0026#34;, err) return err } else if err != nil { fmt.Printf(\u0026#34;err: %v\\n\u0026#34;, err) return err } else { fmt.Printf(\u0026#34;result :%v\\n\u0026#34;, result) } val := rdb.HGet(\u0026#34;user\u0026#34;, \u0026#34;name\u0026#34;).Val() fmt.Printf(\u0026#34;val :%v\\n\u0026#34;, val) return } zset\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 func zSetDemo() { key := \u0026#34;language_rank\u0026#34; languages := []redis.Z{ redis.Z{Score: 100, Member: \u0026#34;Java\u0026#34;}, redis.Z{Score: 99, Member: \u0026#34;Golang\u0026#34;}, redis.Z{Score: 89, Member: \u0026#34;Python\u0026#34;}, redis.Z{Score: 80, Member: \u0026#34;C\u0026#34;}, redis.Z{Score: 0, Member: \u0026#34;C++\u0026#34;}, } //language切片被打散一一add到zset中 result, err := rdb.ZAdd(key, languages...).Result() if err != nil { fmt.Printf(\u0026#34;err :%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;zadd %d success!\u0026#34;, result) //把Golang的分数+10 f, err := rdb.ZIncrBy(key, 10, \u0026#34;Golang\u0026#34;).Result() if err != nil { fmt.Printf(\u0026#34;err :%v\\n\u0026#34;, err) return } fmt.Printf(\u0026#34;new Score is %d\\n\u0026#34;, f) //取最高的三个分数 zs, err := rdb.ZRevRangeWithScores(key, 0, 2).Result() if err != nil { fmt.Printf(\u0026#34;err :%v\\n\u0026#34;, err) return } for i, z := range zs { fmt.Println(i, z.Member, z.Score) } //取90 - 100分的 ranges := redis.ZRangeBy{ Min: \u0026#34;90\u0026#34;, Max: \u0026#34;100\u0026#34;, } strings, err := rdb.ZRevRangeByScoreWithScores(key, ranges).Result() if err != nil { fmt.Printf(\u0026#34;err :%v\\n\u0026#34;, err) return } if err != nil { fmt.Printf(\u0026#34;err :%v\\n\u0026#34;, err) return } for i, z := range strings { fmt.Println(i, z.Member, z.Score) } } pipeline 事务 1 2 3 4 5 6 7 8 9 10 11 12 13 // 监视watch_count的值，并在值不变的前提下将其值+1 key := \u0026#34;watch_count\u0026#34; err = client.Watch(func(tx *redis.Tx) error { n, err := tx.Get(key).Int() if err != nil \u0026amp;\u0026amp; err != redis.Nil { return err } _, err = tx.Pipelined(func(pipe redis.Pipeliner) error { pipe.Set(key, n+1, 0) return nil }) return err }, key) Zap日志库 Gologger Go logger的优劣？ Zap的优点 使用 获得\n​\tgo get -u go.uber.org/zap\n配置zap\nLogger 通过调用zap.NewProduction()/zap.NewDevelopment()或者zap.Example()创建一个Logger。 上面的每一个函数都将创建一个logger。唯一的区别在于它将记录的信息不同。例如production logger默认记录调用函数信息、日期和时间等。 通过Logger调用Info/Error等。 默认情况下日志都会打印到应用程序的console界面。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;net/http\u0026#34; ) var logger *zap.Logger func main() { InitLogg() defer logger.Sync() //将logger的日志刷到磁盘 simpleHttp(\u0026#34;www.google.com\u0026#34;) simpleHttp(\u0026#34;http://www.google.com\u0026#34;) } func InitLogg() { logger, _ = zap.NewProduction() } func simpleHttp(url string) { get, err := http.Get(url) if err != nil { logger.Error(\u0026#34;Error fetching url..\u0026#34;, zap.String(\u0026#34;url\u0026#34;, url), zap.Error(err)) } else { logger.Info(\u0026#34;success..\u0026#34;, zap.String(\u0026#34;statusCode\u0026#34;, get.Status), zap.String(\u0026#34;url\u0026#34;, url)) get.Body.Close() } } 自定义配置项 将日志写入文件而不是终端 我们要做的第一个更改是把日志写入文件，而不是打印到应用程序控制台。\n我们将使用zap.New(…)方法来手动传递所有配置，而不是使用像zap.NewProduction()这样的预置方法来创建logger。 1 func New(core zapcore.Core, options ...Option) *Logger zapcore.Core需要三个配置——Encoder，WriteSyncer，LogLevel。\n1.Encoder:编码器(如何写入日志)。我们将使用开箱即用的NewJSONEncoder()，并使用预先设置的ProductionEncoderConfig()。\n1 zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) 2.WriterSyncer ：指定日志将写到哪里去。我们使用zapcore.AddSync()函数并且将打开的文件句柄传进去。\n1 2 file, _ := os.Create(\u0026#34;./logger.log\u0026#34;) writeSyncer := zapcore.AddSync(file) 3.Log Level：哪种级别的日志将被写入。\n我们将修改上述部分中的Logger代码，并重写InitLogger()方法。其余方法—main() /SimpleHttpGet()保持不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func InitLogg() { writerSync := getLogWriter() encoding := getEncoder() core := zapcore.NewCore(encoding, writerSync, zapcore.DebugLevel) logger = zap.New(core) } func getEncoder() zapcore.Encoder { return zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()) } func getLogWriter() zapcore.WriteSyncer { f, _ := os.Create(\u0026#34;./logger.log\u0026#34;) return zapcore.AddSync(f) } 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。\n1 2 3 4 {\u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;,\u0026#34;ts\u0026#34;:1572160754.994731,\u0026#34;msg\u0026#34;:\u0026#34;Trying to hit GET request for www.sogo.com\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;error\u0026#34;,\u0026#34;ts\u0026#34;:1572160754.994982,\u0026#34;msg\u0026#34;:\u0026#34;Error fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \\\u0026#34;\\\u0026#34;\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;debug\u0026#34;,\u0026#34;ts\u0026#34;:1572160754.994996,\u0026#34;msg\u0026#34;:\u0026#34;Trying to hit GET request for http://www.sogo.com\u0026#34;} {\u0026#34;level\u0026#34;:\u0026#34;info\u0026#34;,\u0026#34;ts\u0026#34;:1572160757.3755069,\u0026#34;msg\u0026#34;:\u0026#34;Success! statusCode = 200 OK for URL http://www.sogo.com\u0026#34;} 将JSON Encoder更改为普通的Log Encoder 现在，我们希望将编码器从JSON Encoder更改为普通Encoder。为此，我们需要将NewJSONEncoder()更改为NewConsoleEncoder()。\n1 return zapcore.NewConsoleEncoder(zap.NewProductionEncoderConfig()) 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。\n1 2 3 4 1.572161051846623e+09\tdebug\tTrying to hit GET request for www.sogo.com 1.572161051846828e+09\terror\tError fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \u0026#34;\u0026#34; 1.5721610518468401e+09\tdebug\tTrying to hit GET request for http://www.sogo.com 1.572161052068744e+09\tinfo\tSuccess! statusCode = 200 OK for URL http://www.sogo.com 更改时间编码并添加调用者详细信息 鉴于我们对配置所做的更改，有下面两个问题：\n时间是以非人类可读的方式展示，例如1.572161051846623e+09 调用方函数的详细信息没有显示在日志中 我们要做的第一件事是覆盖默认的ProductionConfig()，并进行以下更改:\n修改时间编码器 在日志文件中使用大写字母记录日志级别 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func getEncoder() zapcore.Encoder { return zapcore.NewConsoleEncoder( zapcore.EncoderConfig{ TimeKey: \u0026#34;ts\u0026#34;, LevelKey: \u0026#34;level\u0026#34;, NameKey: \u0026#34;logger\u0026#34;, CallerKey: \u0026#34;caller\u0026#34;, FunctionKey: zapcore.OmitKey, MessageKey: \u0026#34;msg\u0026#34;, StacktraceKey: \u0026#34;stacktrace\u0026#34;, LineEnding: zapcore.DefaultLineEnding, EncodeLevel: zapcore.LowercaseLevelEncoder, EncodeTime: zapcore.ISO8601TimeEncoder, EncodeDuration: zapcore.SecondsDurationEncoder, EncodeCaller: zapcore.ShortCallerEncoder, }) } 接下来，我们将修改zap logger代码，添加将调用函数信息记录到日志中的功能。为此，我们将在zap.New(..)函数中添加一个Option。\n1 logger := zap.New(core, zap.AddCaller()) 当使用这些修改过的logger配置调用上述部分的main()函数时，以下输出将打印在文件——test.log中。\n1 2 3 4 2019-10-27T15:33:29.855+0800\tDEBUG\tlogic/temp2.go:47\tTrying to hit GET request for www.sogo.com 2019-10-27T15:33:29.855+0800\tERROR\tlogic/temp2.go:50\tError fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \u0026#34;\u0026#34; 2019-10-27T15:33:29.856+0800\tDEBUG\tlogic/temp2.go:47\tTrying to hit GET request for http://www.sogo.com 2019-10-27T15:33:30.125+0800\tINFO\tlogic/temp2.go:52\tSuccess! statusCode = 200 OK for URL http://www.sogo.com 使用Lumberjack进行日志切割归档 这个日志程序中唯一缺少的就是日志切割归档功能。\nZap本身不支持切割归档日志文件\n为了添加日志切割归档功能，我们将使用第三方库Lumberjack来实现。\n安装 执行下面的命令安装Lumberjack\n1 go get -u github.com/natefinch/lumberjack zap logger中加入Lumberjack 要在zap中加入Lumberjack支持，我们需要修改WriteSyncer代码。我们将按照下面的代码修改getLogWriter()函数：\n1 2 3 4 5 6 7 8 9 10 func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026amp;lumberjack.Logger{ Filename: \u0026#34;./test.log\u0026#34;, MaxSize: 10, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger) } Lumberjack Logger采用以下属性作为输入:\nFilename: 日志文件的位置 MaxSize：在进行切割之前，日志文件的最大大小（以MB为单位） MaxBackups：保留旧文件的最大个数 MaxAges：保留旧文件的最大天数 Compress：是否压缩/归档旧文件 测试所有功能 最终，使用Zap/Lumberjack logger的完整示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package main import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/natefinch/lumberjack\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) var sugarLogger *zap.SugaredLogger func main() { InitLogger() defer sugarLogger.Sync() simpleHttpGet(\u0026#34;www.sogo.com\u0026#34;) simpleHttpGet(\u0026#34;http://www.sogo.com\u0026#34;) } func InitLogger() { writeSyncer := getLogWriter() encoder := getEncoder() core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel) logger := zap.New(core, zap.AddCaller()) sugarLogger = logger.Sugar() } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig) } func getLogWriter() zapcore.WriteSyncer { lumberJackLogger := \u0026amp;lumberjack.Logger{ Filename: \u0026#34;./test.log\u0026#34;, MaxSize: 1, MaxBackups: 5, MaxAge: 30, Compress: false, } return zapcore.AddSync(lumberJackLogger) } func simpleHttpGet(url string) { sugarLogger.Debugf(\u0026#34;Trying to hit GET request for %s\u0026#34;, url) resp, err := http.Get(url) if err != nil { sugarLogger.Errorf(\u0026#34;Error fetching URL %s : Error = %s\u0026#34;, url, err) } else { sugarLogger.Infof(\u0026#34;Success! statusCode = %s for URL %s\u0026#34;, resp.Status, url) resp.Body.Close() } } 执行上述代码，下面的内容会输出到文件——test.log中。\n1 2 3 4 2019-10-27T15:50:32.944+0800\tDEBUG\tlogic/temp2.go:48\tTrying to hit GET request for www.sogo.com 2019-10-27T15:50:32.944+0800\tERROR\tlogic/temp2.go:51\tError fetching URL www.sogo.com : Error = Get www.sogo.com: unsupported protocol scheme \u0026#34;\u0026#34; 2019-10-27T15:50:32.944+0800\tDEBUG\tlogic/temp2.go:48\tTrying to hit GET request for http://www.sogo.com 2019-10-27T15:50:33.165+0800\tINFO\tlogic/temp2.go:53\tSuccess! statusCode = 200 OK for URL http://www.sogo.com 同时，可以在main函数中循环记录日志，测试日志文件是否会自动切割和归档（日志文件每1MB会切割并且在当前目录下最多保存5个备份）。\n至此，我们总结了如何将Zap日志程序集成到Go应用程序项目中。\ngin整合zap go get -u github.com/gin-gonic/gin\n首先我们来看一个最简单的gin项目：\n1 2 3 4 5 6 7 func main() { r := gin.Default() r.GET(\u0026#34;/hello\u0026#34;, func(c *gin.Context) { c.String(\u0026#34;hello liwenzhou.com!\u0026#34;) }) r.Run( } 接下来我们看一下gin.Default()的源码：\n1 2 3 4 5 6 func Default() *Engine { debugPrintWARNINGDefault() engine := New() engine.Use(Logger(), Recovery()) return engine } 也就是我们在使用gin.Default()的同时是用到了gin框架内的两个默认中间件Logger()和Recovery()。\n其中Logger()是把gin框架本身的日志输出到标准输出（我们本地开发调试时在终端输出的那些日志就是它的功劳），而Recovery()是在程序出现panic的时候恢复现场并写入500响应的。\n基于zap的中间件 我们可以模仿Logger()和Recovery()的实现，使用我们的日志库来接收gin框架默认输出的日志。\n这里以zap为例，我们实现两个中间件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // GinLogger 接收gin框架默认的日志 func GinLogger(logger *zap.Logger) gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() cost := time.Since(start) logger.Info(path, zap.Int(\u0026#34;status\u0026#34;, c.Writer.Status()), zap.String(\u0026#34;method\u0026#34;, c.Request.Method), zap.String(\u0026#34;path\u0026#34;, path), zap.String(\u0026#34;query\u0026#34;, query), zap.String(\u0026#34;ip\u0026#34;, c.ClientIP()), zap.String(\u0026#34;user-agent\u0026#34;, c.Request.UserAgent()), zap.String(\u0026#34;errors\u0026#34;, c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\u0026#34;cost\u0026#34;, cost), ) } } // GinRecovery recover掉项目可能出现的panic func GinRecovery(logger *zap.Logger, stack bool) gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \u0026#34;broken pipe\u0026#34;) || strings.Contains(strings.ToLower(se.Error()), \u0026#34;connection reset by peer\u0026#34;) { brokenPipe = true } } } httpRequest, _ := httputil.DumpRequest(c.Request, false) if brokenPipe { logger.Error(c.Request.URL.Path, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) // If the connection is dead, we can\u0026#39;t write a status to it. c.Error(err.(error)) // nolint: errcheck c.Abort() return } if stack { logger.Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), zap.String(\u0026#34;stack\u0026#34;, string(debug.Stack())), ) } else { logger.Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) } c.AbortWithStatus(http.StatusInternalServerError) } }() c.Next() } } 如果不想自己实现，可以使用github上有别人封装好的https://github.com/gin-contrib/zap。\n这样我们就可以在gin框架中使用我们上面定义好的两个中间件来代替gin框架默认的Logger()和Recovery()了。\n1 2 r := gin.New() r.Use(GinLogger(), GinRecovery()) 在gin项目中使用zap 最后我们再加入我们项目中常用的日志切割，完整版的logger.go代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 package logger import ( \u0026#34;gin_zap_demo/config\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httputil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime/debug\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/natefinch/lumberjack\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) var lg *zap.Logger // InitLogger 初始化Logger func InitLogger(cfg *config.LogConfig) (err error) { writeSyncer := getLogWriter(cfg.Filename, cfg.MaxSize, cfg.MaxBackups, cfg.MaxAge) encoder := getEncoder() var l = new(zapcore.Level) err = l.UnmarshalText([]byte(cfg.Level)) if err != nil { return } core := zapcore.NewCore(encoder, writeSyncer, l) lg = zap.New(core, zap.AddCaller()) zap.ReplaceGlobals(lg) // 替换zap包中全局的logger实例，后续在其他包中只需使用zap.L()调用即可 return } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.TimeKey = \u0026#34;time\u0026#34; encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder encoderConfig.EncodeDuration = zapcore.SecondsDurationEncoder encoderConfig.EncodeCaller = zapcore.ShortCallerEncoder return zapcore.NewJSONEncoder(encoderConfig) } func getLogWriter(filename string, maxSize, maxBackup, maxAge int) zapcore.WriteSyncer { lumberJackLogger := \u0026amp;lumberjack.Logger{ Filename: filename, MaxSize: maxSize, MaxBackups: maxBackup, MaxAge: maxAge, } return zapcore.AddSync(lumberJackLogger) } // GinLogger 接收gin框架默认的日志 func GinLogger() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() cost := time.Since(start) lg.Info(path, zap.Int(\u0026#34;status\u0026#34;, c.Writer.Status()), zap.String(\u0026#34;method\u0026#34;, c.Request.Method), zap.String(\u0026#34;path\u0026#34;, path), zap.String(\u0026#34;query\u0026#34;, query), zap.String(\u0026#34;ip\u0026#34;, c.ClientIP()), zap.String(\u0026#34;user-agent\u0026#34;, c.Request.UserAgent()), zap.String(\u0026#34;errors\u0026#34;, c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\u0026#34;cost\u0026#34;, cost), ) } } // GinRecovery recover掉项目可能出现的panic，并使用zap记录相关日志 func GinRecovery(stack bool) gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \u0026#34;broken pipe\u0026#34;) || strings.Contains(strings.ToLower(se.Error()), \u0026#34;connection reset by peer\u0026#34;) { brokenPipe = true } } } httpRequest, _ := httputil.DumpRequest(c.Request, false) if brokenPipe { lg.Error(c.Request.URL.Path, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) // If the connection is dead, we can\u0026#39;t write a status to it. c.Error(err.(error)) // nolint: errcheck c.Abort() return } if stack { lg.Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), zap.String(\u0026#34;stack\u0026#34;, string(debug.Stack())), ) } else { lg.Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) } c.AbortWithStatus(http.StatusInternalServerError) } }() c.Next() } } 然后定义日志相关配置：\n1 2 3 4 5 6 7 type LogConfig struct { Level string `json:\u0026#34;level\u0026#34;` Filename string `json:\u0026#34;filename\u0026#34;` MaxSize int `json:\u0026#34;maxsize\u0026#34;` MaxAge int `json:\u0026#34;max_age\u0026#34;` MaxBackups int `json:\u0026#34;max_backups\u0026#34;` } 在项目中先从配置文件加载配置信息，再调用logger.InitLogger(config.Conf.LogConfig)即可完成logger实例的初识化。其中，通过r.Use(logger.GinLogger(), logger.GinRecovery(true))注册我们的中间件来使用zap接收gin框架自身的日志，在项目中需要的地方通过使用zap.L().Xxx()方法来记录自定义日志信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;gin_zap_demo/config\u0026#34; \u0026#34;gin_zap_demo/logger\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { // load config from config.json if len(os.Args) \u0026lt; 1 { return } if err := config.Init(os.Args[1]); err != nil { panic(err) } // init logger if err := logger.InitLogger(config.Conf.LogConfig); err != nil { fmt.Printf(\u0026#34;init logger failed, err:%v\\n\u0026#34;, err) return } gin.SetMode(config.Conf.Mode) r := gin.Default() // 注册zap相关中间件 r.Use(logger.GinLogger(), logger.GinRecovery(true)) r.GET(\u0026#34;/hello\u0026#34;, func(c *gin.Context) { // 假设你有一些数据需要记录到日志中 var ( name = \u0026#34;q1mi\u0026#34; age = 18 ) // 记录日志并使用zap.Xxx(key, val)记录相关字段 zap.L().Debug(\u0026#34;this is hello func\u0026#34;, zap.String(\u0026#34;user\u0026#34;, name), zap.Int(\u0026#34;age\u0026#34;, age)) c.String(http.StatusOK, \u0026#34;hello liwenzhou.com!\u0026#34;) }) addr := fmt.Sprintf(\u0026#34;:%v\u0026#34;, config.Conf.Port) r.Run(addr) } Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。\nViper Viper是适用于Go应用程序的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。\n鉴于viper库本身的README已经写得十分详细，这里就将其翻译成中文，并在最后附上两个项目中使用viper的示例代码以供参考。\n安装 1 go get github.com/spf13/viper 什么是Viper？ Viper是适用于Go应用程序（包括Twelve-Factor App）的完整配置解决方案。它被设计用于在应用程序中工作，并且可以处理所有类型的配置需求和格式。它支持以下特性：\n设置默认值 从JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件读取配置信息 实时监控和重新读取配置文件（可选） 从环境变量中读取 从远程配置系统（etcd或Consul）读取并监控配置变化 从命令行参数读取配置 从buffer读取配置 显式配置值 为什么选择Viper? 在构建现代应用程序时，你无需担心配置文件格式；你想要专注于构建出色的软件。Viper的出现就是为了在这方面帮助你的。\nViper能够为你执行下列操作：\n查找、加载和反序列化JSON、TOML、YAML、HCL、INI、envfile和Java properties格式的配置文件。 提供一种机制为你的不同配置选项设置默认值。 提供一种机制来通过命令行参数覆盖指定选项的值。 提供别名系统，以便在不破坏现有代码的情况下轻松重命名参数。 当用户提供了与默认值相同的命令行或配置文件时，可以很容易地分辨出它们之间的区别。 Viper会按照下面的优先级。每个项目的优先级都高于它下面的项目:\n显示调用Set设置值 命令行参数（flag） 环境变量 配置文件 key/value存储 默认值 重要： 目前Viper配置的键（Key）是大小写不敏感的。目前正在讨论是否将这一选项设为可选。\n把值存入Viper 建立默认值 一个好的配置系统应该支持默认值。键不需要默认值，但如果没有通过配置文件、环境变量、远程配置或命令行标志（flag）设置键，则默认值非常有用。\n例如：\n1 2 3 viper.SetDefault(\u0026#34;ContentDir\u0026#34;, \u0026#34;content\u0026#34;) viper.SetDefault(\u0026#34;LayoutDir\u0026#34;, \u0026#34;layouts\u0026#34;) viper.SetDefault(\u0026#34;Taxonomies\u0026#34;, map[string]string{\u0026#34;tag\u0026#34;: \u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;: \u0026#34;categories\u0026#34;}) 读取配置文件 Viper需要最少知道在哪里查找配置文件的配置。Viper支持JSON、TOML、YAML、HCL、envfile和Java properties格式的配置文件。Viper可以搜索多个路径，但目前单个Viper实例只支持单个配置文件。Viper不默认任何配置搜索路径，将默认决策留给应用程序。\n下面是一个如何使用Viper搜索和读取配置文件的示例。不需要任何特定的路径，但是至少应该提供一个配置文件预期出现的路径。\n1 2 3 4 5 6 7 8 9 10 viper.SetConfigFile(\u0026#34;./config.yaml\u0026#34;) // 指定配置文件路径 viper.SetConfigName(\u0026#34;config\u0026#34;) // 配置文件名称(无扩展名) viper.SetConfigType(\u0026#34;yaml\u0026#34;) // 如果配置文件的名称中没有扩展名，则需要配置此项 viper.AddConfigPath(\u0026#34;/etc/appname/\u0026#34;) // 查找配置文件所在的路径 viper.AddConfigPath(\u0026#34;$HOME/.appname\u0026#34;) // 多次调用以添加多个搜索路径 viper.AddConfigPath(\u0026#34;.\u0026#34;) // 还可以在工作目录中查找配置 err := viper.ReadInConfig() // 查找并读取配置文件 if err != nil { // 处理读取配置文件的错误 panic(fmt.Errorf(\u0026#34;Fatal error config file: %s \\n\u0026#34;, err)) } 在加载配置文件出错时，你可以像下面这样处理找不到配置文件的特定情况：\n1 2 3 4 5 6 7 8 9 if err := viper.ReadInConfig(); err != nil { if _, ok := err.(viper.ConfigFileNotFoundError); ok { // 配置文件未找到错误；如果需要可以忽略 } else { // 配置文件被找到，但产生了另外的错误 } } // 配置文件找到并成功解析 注意[自1.6起]： 你也可以有不带扩展名的文件，并以编程方式指定其格式。对于位于用户$HOME目录中的配置文件没有任何扩展名，如.bashrc。\n这里补充两个问题供读者解答并自行验证\n当你使用如下方式读取配置时，viper会从./conf目录下查找任何以config为文件名的配置文件，如果同时存在./conf/config.json和./conf/config.yaml两个配置文件的话，viper会从哪个配置文件加载配置呢？\n1 2 viper.SetConfigName(\u0026#34;config\u0026#34;) viper.AddConfigPath(\u0026#34;./conf\u0026#34;) 在上面两个语句下搭配使用viper.SetConfigType(\u0026quot;yaml\u0026quot;)指定配置文件类型可以实现预期的效果吗？\n写入配置文件 从配置文件中读取配置文件是有用的，但是有时你想要存储在运行时所做的所有修改。为此，可以使用下面一组命令，每个命令都有自己的用途:\nWriteConfig - 将当前的viper配置写入预定义的路径并覆盖（如果存在的话）。如果没有预定义的路径，则报错。 SafeWriteConfig - 将当前的viper配置写入预定义的路径。如果没有预定义的路径，则报错。如果存在，将不会覆盖当前的配置文件。 WriteConfigAs - 将当前的viper配置写入给定的文件路径。将覆盖给定的文件(如果它存在的话)。 SafeWriteConfigAs - 将当前的viper配置写入给定的文件路径。不会覆盖给定的文件(如果它存在的话)。 根据经验，标记为safe的所有方法都不会覆盖任何文件，而是直接创建（如果不存在），而默认行为是创建或截断。\n一个小示例：\n1 2 3 4 5 viper.WriteConfig() // 将当前配置写入“viper.AddConfigPath()”和“viper.SetConfigName”设置的预定义路径 viper.SafeWriteConfig() viper.WriteConfigAs(\u0026#34;/path/to/my/.config\u0026#34;) viper.SafeWriteConfigAs(\u0026#34;/path/to/my/.config\u0026#34;) // 因为该配置文件写入过，所以会报错 viper.SafeWriteConfigAs(\u0026#34;/path/to/my/.other_config\u0026#34;) 监控并重新读取配置文件 Viper支持在运行时实时读取配置文件的功能。\n需要重新启动服务器以使配置生效的日子已经一去不复返了，viper驱动的应用程序可以在运行时读取配置文件的更新，而不会错过任何消息。\n只需告诉viper实例watchConfig。可选地，你可以为Viper提供一个回调函数，以便在每次发生更改时运行。\n确保在调用WatchConfig()之前添加了所有的配置路径。\n1 2 3 4 5 viper.WatchConfig() viper.OnConfigChange(func(e fsnotify.Event) { // 配置文件发生变更之后会调用的回调函数 fmt.Println(\u0026#34;Config file changed:\u0026#34;, e.Name) }) 从io.Reader读取配置 Viper预先定义了许多配置源，如文件、环境变量、标志和远程K/V存储，但你不受其约束。你还可以实现自己所需的配置源并将其提供给viper。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 viper.SetConfigType(\u0026#34;yaml\u0026#34;) // 或者 viper.SetConfigType(\u0026#34;YAML\u0026#34;) // 任何需要将此配置添加到程序中的方法。 var yamlExample = []byte(` Hacker: true name: steve hobbies: - skateboarding - snowboarding - go clothing: jacket: leather trousers: denim age: 35 eyes : brown beard: true `) viper.ReadConfig(bytes.NewBuffer(yamlExample)) viper.Get(\u0026#34;name\u0026#34;) // 这里会得到 \u0026#34;steve\u0026#34; 覆盖设置 这些可能来自命令行标志，也可能来自你自己的应用程序逻辑。\n1 2 viper.Set(\u0026#34;Verbose\u0026#34;, true) viper.Set(\u0026#34;LogFile\u0026#34;, LogFile) 注册和使用别名 别名允许多个键引用单个值\n1 2 3 4 5 6 7 viper.RegisterAlias(\u0026#34;loud\u0026#34;, \u0026#34;Verbose\u0026#34;) // 注册别名（此处loud和Verbose建立了别名） viper.Set(\u0026#34;verbose\u0026#34;, true) // 结果与下一行相同 viper.Set(\u0026#34;loud\u0026#34;, true) // 结果与前一行相同 viper.GetBool(\u0026#34;loud\u0026#34;) // true viper.GetBool(\u0026#34;verbose\u0026#34;) // true 使用环境变量 Viper完全支持环境变量。这使Twelve-Factor App开箱即用。有五种方法可以帮助与ENV协作:\nAutomaticEnv() BindEnv(string...) : error SetEnvPrefix(string) SetEnvKeyReplacer(string...) *strings.Replacer AllowEmptyEnv(bool) 使用ENV变量时，务必要意识到Viper将ENV变量视为区分大小写。\nViper提供了一种机制来确保ENV变量是惟一的。通过使用SetEnvPrefix，你可以告诉Viper在读取环境变量时使用前缀。BindEnv和AutomaticEnv都将使用这个前缀。\nBindEnv使用一个或两个参数。第一个参数是键名称，第二个是环境变量的名称。环境变量的名称区分大小写。如果没有提供ENV变量名，那么Viper将自动假设ENV变量与以下格式匹配：前缀+ “_” +键名全部大写。当你显式提供ENV变量名（第二个参数）时，它 不会 自动添加前缀。例如，如果第二个参数是“id”，Viper将查找环境变量“ID”。\n在使用ENV变量时，需要注意的一件重要事情是，每次访问该值时都将读取它。Viper在调用BindEnv时不固定该值。\nAutomaticEnv是一个强大的助手，尤其是与SetEnvPrefix结合使用时。调用时，Viper会在发出viper.Get请求时随时检查环境变量。它将应用以下规则。它将检查环境变量的名称是否与键匹配（如果设置了EnvPrefix）。\nSetEnvKeyReplacer允许你使用strings.Replacer对象在一定程度上重写 Env 键。如果你希望在Get()调用中使用-或者其他什么符号，但是环境变量里使用_分隔符，那么这个功能是非常有用的。可以在viper_test.go中找到它的使用示例。\n或者，你可以使用带有NewWithOptions工厂函数的EnvKeyReplacer。与SetEnvKeyReplacer不同，它接受StringReplacer接口，允许你编写自定义字符串替换逻辑。\n默认情况下，空环境变量被认为是未设置的，并将返回到下一个配置源。若要将空环境变量视为已设置，请使用AllowEmptyEnv方法。\nEnv 示例： 1 2 3 4 5 6 SetEnvPrefix(\u0026#34;spf\u0026#34;) // 将自动转为大写 BindEnv(\u0026#34;id\u0026#34;) os.Setenv(\u0026#34;SPF_ID\u0026#34;, \u0026#34;13\u0026#34;) // 通常是在应用程序之外完成的 id := Get(\u0026#34;id\u0026#34;) // 13 使用Flags Viper 具有绑定到标志的能力。具体来说，Viper支持Cobra库中使用的Pflag。\n与BindEnv类似，该值不是在调用绑定方法时设置的，而是在访问该方法时设置的。这意味着你可以根据需要尽早进行绑定，即使在init()函数中也是如此。\n对于单个标志，BindPFlag()方法提供此功能。\n例如：\n1 2 serverCmd.Flags().Int(\u0026#34;port\u0026#34;, 1138, \u0026#34;Port to run Application server on\u0026#34;) viper.BindPFlag(\u0026#34;port\u0026#34;, serverCmd.Flags().Lookup(\u0026#34;port\u0026#34;)) 你还可以绑定一组现有的pflags （pflag.FlagSet）：\n举个例子：\n1 2 3 4 5 6 pflag.Int(\u0026#34;flagname\u0026#34;, 1234, \u0026#34;help message for flagname\u0026#34;) pflag.Parse() viper.BindPFlags(pflag.CommandLine) i := viper.GetInt(\u0026#34;flagname\u0026#34;) // 从viper而不是从pflag检索值 在 Viper 中使用 pflag 并不阻碍其他包中使用标准库中的 flag 包。pflag 包可以通过导入这些 flags 来处理flag包定义的flags。这是通过调用pflag包提供的便利函数AddGoFlagSet()来实现的。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( \u0026#34;flag\u0026#34; \u0026#34;github.com/spf13/pflag\u0026#34; ) func main() { // 使用标准库 \u0026#34;flag\u0026#34; 包 flag.Int(\u0026#34;flagname\u0026#34;, 1234, \u0026#34;help message for flagname\u0026#34;) pflag.CommandLine.AddGoFlagSet(flag.CommandLine) pflag.Parse() viper.BindPFlags(pflag.CommandLine) i := viper.GetInt(\u0026#34;flagname\u0026#34;) // 从 viper 检索值 ... } flag接口 如果你不使用Pflag，Viper 提供了两个Go接口来绑定其他 flag 系统。\nFlagValue表示单个flag。这是一个关于如何实现这个接口的非常简单的例子：\n1 2 3 4 5 type myFlag struct {} func (f myFlag) HasChanged() bool { return false } func (f myFlag) Name() string { return \u0026#34;my-flag-name\u0026#34; } func (f myFlag) ValueString() string { return \u0026#34;my-flag-value\u0026#34; } func (f myFlag) ValueType() string { return \u0026#34;string\u0026#34; } 一旦你的 flag 实现了这个接口，你可以很方便地告诉Viper绑定它：\n1 viper.BindFlagValue(\u0026#34;my-flag-name\u0026#34;, myFlag{}) FlagValueSet代表一组 flags 。这是一个关于如何实现这个接口的非常简单的例子:\n1 2 3 4 5 6 7 8 9 type myFlagSet struct { flags []myFlag } func (f myFlagSet) VisitAll(fn func(FlagValue)) { for _, flag := range flags { fn(flag) } } 一旦你的flag set实现了这个接口，你就可以很方便地告诉Viper绑定它：\n1 2 3 4 fSet := myFlagSet{ flags: []myFlag{myFlag{}, myFlag{}}, } viper.BindFlagValues(\u0026#34;my-flags\u0026#34;, fSet) 远程Key/Value存储支持 在Viper中启用远程支持，需要在代码中匿名导入viper/remote这个包。\n1 import _ \u0026#34;github.com/spf13/viper/remote\u0026#34; Viper将读取从Key/Value存储（例如etcd或Consul）中的路径检索到的配置字符串（如JSON、TOML、YAML、HCL、envfile和Java properties格式）。这些值的优先级高于默认值，但是会被从磁盘、flag或环境变量检索到的配置值覆盖。（译注：也就是说Viper加载配置值的优先级为：磁盘上的配置文件\u0026gt;命令行标志位\u0026gt;环境变量\u0026gt;远程Key/Value存储\u0026gt;默认值。）\nViper使用crypt从K/V存储中检索配置，这意味着如果你有正确的gpg密匙，你可以将配置值加密存储并自动解密。加密是可选的。\n你可以将远程配置与本地配置结合使用，也可以独立使用。\ncrypt有一个命令行助手，你可以使用它将配置放入K/V存储中。crypt默认使用在http://127.0.0.1:4001的etcd。\n1 2 $ go get github.com/bketelsen/crypt/bin/crypt $ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json 确认值已经设置：\n1 $ crypt get -plaintext /config/hugo.json 有关如何设置加密值或如何使用Consul的示例，请参见crypt文档。\n远程Key/Value存储示例-未加密 etcd 1 2 3 viper.AddRemoteProvider(\u0026#34;etcd\u0026#34;, \u0026#34;http://127.0.0.1:4001\u0026#34;,\u0026#34;/config/hugo.json\u0026#34;) viper.SetConfigType(\u0026#34;json\u0026#34;) // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \u0026#34;json\u0026#34;, \u0026#34;toml\u0026#34;, \u0026#34;yaml\u0026#34;, \u0026#34;yml\u0026#34;, \u0026#34;properties\u0026#34;, \u0026#34;props\u0026#34;, \u0026#34;prop\u0026#34;, \u0026#34;env\u0026#34;, \u0026#34;dotenv\u0026#34; err := viper.ReadRemoteConfig() Consul 你需要 Consul Key/Value存储中设置一个Key保存包含所需配置的JSON值。例如，创建一个keyMY_CONSUL_KEY将下面的值存入Consul key/value 存储：\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;port\u0026#34;: 8080, \u0026#34;hostname\u0026#34;: \u0026#34;liwenzhou.com\u0026#34; } viper.AddRemoteProvider(\u0026#34;consul\u0026#34;, \u0026#34;localhost:8500\u0026#34;, \u0026#34;MY_CONSUL_KEY\u0026#34;) viper.SetConfigType(\u0026#34;json\u0026#34;) // 需要显示设置成json err := viper.ReadRemoteConfig() fmt.Println(viper.Get(\u0026#34;port\u0026#34;)) // 8080 fmt.Println(viper.Get(\u0026#34;hostname\u0026#34;)) // liwenzhou.com Firestore 1 2 3 viper.AddRemoteProvider(\u0026#34;firestore\u0026#34;, \u0026#34;google-cloud-project-id\u0026#34;, \u0026#34;collection/document\u0026#34;) viper.SetConfigType(\u0026#34;json\u0026#34;) // 配置的格式: \u0026#34;json\u0026#34;, \u0026#34;toml\u0026#34;, \u0026#34;yaml\u0026#34;, \u0026#34;yml\u0026#34; err := viper.ReadRemoteConfig() 当然，你也可以使用SecureRemoteProvider。\n远程Key/Value存储示例-加密 1 2 3 viper.AddSecureRemoteProvider(\u0026#34;etcd\u0026#34;,\u0026#34;http://127.0.0.1:4001\u0026#34;,\u0026#34;/config/hugo.json\u0026#34;,\u0026#34;/etc/secrets/mykeyring.gpg\u0026#34;) viper.SetConfigType(\u0026#34;json\u0026#34;) // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \u0026#34;json\u0026#34;, \u0026#34;toml\u0026#34;, \u0026#34;yaml\u0026#34;, \u0026#34;yml\u0026#34;, \u0026#34;properties\u0026#34;, \u0026#34;props\u0026#34;, \u0026#34;prop\u0026#34;, \u0026#34;env\u0026#34;, \u0026#34;dotenv\u0026#34; err := viper.ReadRemoteConfig() 监控etcd中的更改-未加密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 或者你可以创建一个新的viper实例 var runtime_viper = viper.New() runtime_viper.AddRemoteProvider(\u0026#34;etcd\u0026#34;, \u0026#34;http://127.0.0.1:4001\u0026#34;, \u0026#34;/config/hugo.yml\u0026#34;) runtime_viper.SetConfigType(\u0026#34;yaml\u0026#34;) // 因为在字节流中没有文件扩展名，所以这里需要设置下类型。支持的扩展名有 \u0026#34;json\u0026#34;, \u0026#34;toml\u0026#34;, \u0026#34;yaml\u0026#34;, \u0026#34;yml\u0026#34;, \u0026#34;properties\u0026#34;, \u0026#34;props\u0026#34;, \u0026#34;prop\u0026#34;, \u0026#34;env\u0026#34;, \u0026#34;dotenv\u0026#34; // 第一次从远程读取配置 err := runtime_viper.ReadRemoteConfig() // 反序列化 runtime_viper.Unmarshal(\u0026amp;runtime_conf) // 开启一个单独的goroutine一直监控远端的变更 go func(){ for { time.Sleep(time.Second * 5) // 每次请求后延迟一下 // 目前只测试了etcd支持 err := runtime_viper.WatchRemoteConfig() if err != nil { log.Errorf(\u0026#34;unable to read remote config: %v\u0026#34;, err) continue } // 将新配置反序列化到我们运行时的配置结构体中。你还可以借助channel实现一个通知系统更改的信号 runtime_viper.Unmarshal(\u0026amp;runtime_conf) } }() 从Viper获取值 在Viper中，有几种方法可以根据值的类型获取值。存在以下功能和方法:\nGet(key string) : interface{} GetBool(key string) : bool GetFloat64(key string) : float64 GetInt(key string) : int GetIntSlice(key string) : []int GetString(key string) : string GetStringMap(key string) : map[string]interface{} GetStringMapString(key string) : map[string]string GetStringSlice(key string) : []string GetTime(key string) : time.Time GetDuration(key string) : time.Duration IsSet(key string) : bool AllSettings() : map[string]interface{} 需要认识到的一件重要事情是，每一个Get方法在找不到值的时候都会返回零值。为了检查给定的键是否存在，提供了IsSet()方法。\n例如：\n1 2 3 4 viper.GetString(\u0026#34;logfile\u0026#34;) // 不区分大小写的设置和获取 if viper.GetBool(\u0026#34;verbose\u0026#34;) { fmt.Println(\u0026#34;verbose enabled\u0026#34;) } 访问嵌套的键 访问器方法也接受深度嵌套键的格式化路径。例如，如果加载下面的JSON文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;host\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 5799 }, \u0026#34;datastore\u0026#34;: { \u0026#34;metric\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 3099 }, \u0026#34;warehouse\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;198.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 2112 } } } Viper可以通过传入.分隔的路径来访问嵌套字段：\n1 GetString(\u0026#34;datastore.metric.host\u0026#34;) // (返回 \u0026#34;127.0.0.1\u0026#34;) 这遵守上面建立的优先规则；搜索路径将遍历其余配置注册表，直到找到为止。(译注：因为Viper支持从多种配置来源，例如磁盘上的配置文件\u0026gt;命令行标志位\u0026gt;环境变量\u0026gt;远程Key/Value存储\u0026gt;默认值，我们在查找一个配置的时候如果在当前配置源中没找到，就会继续从后续的配置源查找，直到找到为止。)\n例如，在给定此配置文件的情况下，datastore.metric.host和datastore.metric.port均已定义（并且可以被覆盖）。如果另外在默认值中定义了datastore.metric.protocol，Viper也会找到它。\n然而，如果datastore.metric被直接赋值覆盖（被flag，环境变量，set()方法等等…），那么datastore.metric的所有子键都将变为未定义状态，它们被高优先级配置级别“遮蔽”（shadowed）了。\n最后，如果存在与分隔的键路径匹配的键，则返回其值。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;datastore.metric.host\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;host\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 5799 }, \u0026#34;datastore\u0026#34;: { \u0026#34;metric\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 3099 }, \u0026#34;warehouse\u0026#34;: { \u0026#34;host\u0026#34;: \u0026#34;198.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 2112 } } } GetString(\u0026#34;datastore.metric.host\u0026#34;) // 返回 \u0026#34;0.0.0.0\u0026#34; 提取子树 从Viper中提取子树。\n例如，viper实例现在代表了以下配置：\n1 2 3 4 5 6 7 app: cache1: max-items: 100 item-size: 64 cache2: max-items: 200 item-size: 80 执行后：\n1 subv := viper.Sub(\u0026#34;app.cache1\u0026#34;) subv现在就代表：\n1 2 max-items: 100 item-size: 64 假设我们现在有这么一个函数：\n1 func NewCache(cfg *Viper) *Cache {...} 它基于subv格式的配置信息创建缓存。现在，可以轻松地分别创建这两个缓存，如下所示：\n1 2 3 4 5 cfg1 := viper.Sub(\u0026#34;app.cache1\u0026#34;) cache1 := NewCache(cfg1) cfg2 := viper.Sub(\u0026#34;app.cache2\u0026#34;) cache2 := NewCache(cfg2) 反序列化 你还可以选择将所有或特定的值解析到结构体、map等。\n有两种方法可以做到这一点：\nUnmarshal(rawVal interface{}) : error UnmarshalKey(key string, rawVal interface{}) : error 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 type config struct { Port int Name string PathMap string `mapstructure:\u0026#34;path_map\u0026#34;` } var C config err := viper.Unmarshal(\u0026amp;C) if err != nil { t.Fatalf(\u0026#34;unable to decode into struct, %v\u0026#34;, err) } 如果你想要解析那些键本身就包含.(默认的键分隔符）的配置，你需要修改分隔符：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 v := viper.NewWithOptions(viper.KeyDelimiter(\u0026#34;::\u0026#34;)) v.SetDefault(\u0026#34;chart::values\u0026#34;, map[string]interface{}{ \u0026#34;ingress\u0026#34;: map[string]interface{}{ \u0026#34;annotations\u0026#34;: map[string]interface{}{ \u0026#34;traefik.frontend.rule.type\u0026#34;: \u0026#34;PathPrefix\u0026#34;, \u0026#34;traefik.ingress.kubernetes.io/ssl-redirect\u0026#34;: \u0026#34;true\u0026#34;, }, }, }) type config struct { Chart struct{ Values map[string]interface{} } } var C config v.Unmarshal(\u0026amp;C) Viper还支持解析到嵌入的结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Example config: module: enabled: true token: 89h3f98hbwf987h3f98wenf89ehf */ type config struct { Module struct { Enabled bool moduleConfig `mapstructure:\u0026#34;,squash\u0026#34;` } } // moduleConfig could be in a module specific package type moduleConfig struct { Token string } var C config err := viper.Unmarshal(\u0026amp;C) if err != nil { t.Fatalf(\u0026#34;unable to decode into struct, %v\u0026#34;, err) } Viper在后台使用github.com/mitchellh/mapstructure来解析值，其默认情况下使用mapstructuretag。\n注意 当我们需要将viper读取的配置反序列到我们定义的结构体变量中时，一定要使用mapstructuretag哦！\n序列化成字符串 你可能需要将viper中保存的所有设置序列化到一个字符串中，而不是将它们写入到一个文件中。你可以将自己喜欢的格式的序列化器与AllSettings()返回的配置一起使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import ( yaml \u0026#34;gopkg.in/yaml.v2\u0026#34; // ... ) func yamlStringSettings() string { c := viper.AllSettings() bs, err := yaml.Marshal(c) if err != nil { log.Fatalf(\u0026#34;unable to marshal config to YAML: %v\u0026#34;, err) } return string(bs) } 使用单个还是多个Viper实例? Viper是开箱即用的。你不需要配置或初始化即可开始使用Viper。由于大多数应用程序都希望使用单个中央存储库管理它们的配置信息，所以viper包提供了这个功能。它类似于单例模式。\n在上面的所有示例中，它们都以其单例风格的方法演示了如何使用viper。\n使用多个viper实例 你还可以在应用程序中创建许多不同的viper实例。每个都有自己独特的一组配置和值。每个人都可以从不同的配置文件，key value存储区等读取数据。每个都可以从不同的配置文件、键值存储等中读取。viper包支持的所有功能都被镜像为viper实例的方法。\n例如：\n1 2 3 4 5 6 7 x := viper.New() y := viper.New() x.SetDefault(\u0026#34;ContentDir\u0026#34;, \u0026#34;content\u0026#34;) y.SetDefault(\u0026#34;ContentDir\u0026#34;, \u0026#34;foobar\u0026#34;) //... 当使用多个viper实例时，由用户来管理不同的viper实例。\n使用Viper示例 假设我们的项目现在有一个./conf/config.yaml配置文件，内容如下：\n1 2 port: 8123 version: \u0026#34;v1.2.3\u0026#34; 接下来通过示例代码演示两种在项目中使用viper管理项目配置信息的方式。\n直接使用viper管理配置 这里用一个demo演示如何在gin框架搭建的web项目中使用viper，使用viper加载配置文件中的信息，并在代码中直接使用viper.GetXXX()方法获取对应的配置值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func main() { viper.SetConfigFile(\u0026#34;./conf/config.yaml\u0026#34;) // 指定配置文件路径 err := viper.ReadInConfig() // 读取配置信息 if err != nil { // 读取配置信息失败 panic(fmt.Errorf(\u0026#34;Fatal error config file: %s \\n\u0026#34;, err)) } // 监控配置文件变化 viper.WatchConfig() r := gin.Default() // 访问/version的返回值会随配置文件的变化而变化 r.GET(\u0026#34;/version\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK, viper.GetString(\u0026#34;version\u0026#34;)) }) if err := r.Run( fmt.Sprintf(\u0026#34;:%d\u0026#34;, viper.GetInt(\u0026#34;port\u0026#34;))); err != nil { panic(err) } } 使用结构体变量保存配置信息 除了上面的用法外，我们还可以在项目中定义与配置文件对应的结构体，viper加载完配置信息后使用结构体变量保存配置信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) type Config struct { Port int `mapstructure:\u0026#34;port\u0026#34;` Version string `mapstructure:\u0026#34;version\u0026#34;` } var Conf = new(Config) func main() { viper.SetConfigFile(\u0026#34;./conf/config.yaml\u0026#34;) // 指定配置文件路径 err := viper.ReadInConfig() // 读取配置信息 if err != nil { // 读取配置信息失败 panic(fmt.Errorf(\u0026#34;Fatal error config file: %s \\n\u0026#34;, err)) } // 将读取的配置信息保存至全局变量Conf if err := viper.Unmarshal(Conf); err != nil { panic(fmt.Errorf(\u0026#34;unmarshal conf failed, err:%s \\n\u0026#34;, err)) } // 监控配置文件变化 viper.WatchConfig() // 注意！！！配置文件发生变化后要同步到全局变量Conf viper.OnConfigChange(func(in fsnotify.Event) { fmt.Println(\u0026#34;夭寿啦~配置文件被人修改啦...\u0026#34;) if err := viper.Unmarshal(Conf); err != nil { panic(fmt.Errorf(\u0026#34;unmarshal conf failed, err:%s \\n\u0026#34;, err)) } }) r := gin.Default() // 访问/version的返回值会随配置文件的变化而变化 r.GET(\u0026#34;/version\u0026#34;, func(c *gin.Context) { c.String(http.StatusOK, Conf.Version) }) if err := r.Run(fmt.Sprintf(\u0026#34;:%d\u0026#34;, Conf.Port)); err != nil { panic(err) } } 优雅的关机 我们编写的Web项目部署之后，经常会因为需要进行配置变更或功能迭代而重启服务，单纯的kill -9 pid的方式会强制关闭进程，这样就会导致服务端当前正在处理的请求失败，那有没有更优雅的方式来实现关机或重启呢？\n阅读本文需要了解一些UNIX系统中信号的概念，请提前查阅资料预习。\n优雅地关机 什么是优雅关机？ 优雅关机就是服务端关机命令发出后不是立即关机，而是等待当前还在处理的请求全部处理完毕后再退出程序，是一种对客户端友好的关机方式。而执行Ctrl+C关闭服务端时，会强制结束进程导致正在访问的请求出现问题。\n如何实现优雅关机？ Go 1.8版本之后， http.Server 内置的 Shutdown() 方法就支持优雅地关机，具体示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // +build go1.8 package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/signal\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { router := gin.Default() router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { time.Sleep(5 * time.Second) c.String(http.StatusOK, \u0026#34;Welcome Gin Server\u0026#34;) }) srv := \u0026amp;http.Server{ Addr: \u0026#34;:8080\u0026#34;, Handler: router, } go func() { // 开启一个goroutine启动服务 if err := srv.ListenAndServe(); err != nil \u0026amp;\u0026amp; err != http.ErrServerClosed { log.Fatalf(\u0026#34;listen: %s\\n\u0026#34;, err) } }() // 等待中断信号来优雅地关闭服务器，为关闭服务器操作设置一个5秒的超时 quit := make(chan os.Signal, 1) // 创建一个接收信号的通道 // kill 默认会发送 syscall.SIGTERM 信号 // kill -2 发送 syscall.SIGINT 信号，我们常用的Ctrl+C就是触发系统SIGINT信号 // kill -9 发送 syscall.SIGKILL 信号，但是不能被捕获，所以不需要添加它 // signal.Notify把收到的 syscall.SIGINT或syscall.SIGTERM 信号转发给quit signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) // 此处不会阻塞 \u0026lt;-quit // 阻塞在此，当接收到上述两种信号时才会往下执行 log.Println(\u0026#34;Shutdown Server ...\u0026#34;) // 创建一个5秒超时的context ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() // 5秒内优雅关闭服务（将未处理完的请求处理完再关闭服务），超过5秒就超时退出 if err := srv.Shutdown(ctx); err != nil { log.Fatal(\u0026#34;Server Shutdown: \u0026#34;, err) } log.Println(\u0026#34;Server exiting\u0026#34;) } 如何验证优雅关机的效果呢？\n上面的代码运行后会在本地的8080端口开启一个web服务，它只注册了一条路由/，后端服务会先sleep 5秒钟然后才返回响应信息。\n我们按下Ctrl+C时会发送syscall.SIGINT来通知程序优雅关机，具体做法如下：\n打开终端，编译并执行上面的代码 打开一个浏览器，访问127.0.0.1:8080/，此时浏览器白屏等待服务端返回响应。 在终端迅速执行Ctrl+C命令给程序发送syscall.SIGINT信号 此时程序并不立即退出而是等我们第2步的响应返回之后再退出，从而实现优雅关机。 优雅地重启 优雅关机实现了，那么该如何实现优雅重启呢？\n我们可以使用 fvbock/endless 来替换默认的 ListenAndServe启动服务来实现， 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/fvbock/endless\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { router := gin.Default() router.GET(\u0026#34;/\u0026#34;, func(c *gin.Context) { time.Sleep(5 * time.Second) c.String(http.StatusOK, \u0026#34;hello gin!\u0026#34;) }) // 默认endless服务器会监听下列信号： // syscall.SIGHUP，syscall.SIGUSR1，syscall.SIGUSR2，syscall.SIGINT，syscall.SIGTERM和syscall.SIGTSTP // 接收到 SIGHUP 信号将触发`fork/restart` 实现优雅重启（kill -1 pid会发送SIGHUP信号） // 接收到 syscall.SIGINT或syscall.SIGTERM 信号将触发优雅关机 // 接收到 SIGUSR2 信号将触发HammerTime // SIGUSR1 和 SIGTSTP 被用来触发一些用户自定义的hook函数 if err := endless.ListenAndServe(\u0026#34;:8080\u0026#34;, router); err!=nil{ log.Fatalf(\u0026#34;listen: %s\\n\u0026#34;, err) } log.Println(\u0026#34;Server exiting\u0026#34;) } 如何验证优雅重启的效果呢？\n我们通过执行kill -1 pid命令发送syscall.SIGINT来通知程序优雅重启，具体做法如下：\n打开终端，go build -o graceful_restart编译并执行./graceful_restart,终端输出当前pid(假设为43682) 将代码中处理请求函数返回的hello gin!修改为hello q1mi!，再次编译go build -o graceful_restart 打开一个浏览器，访问127.0.0.1:8080/，此时浏览器白屏等待服务端返回响应。 在终端迅速执行kill -1 43682命令给程序发送syscall.SIGHUP信号 等第3步浏览器收到响应信息hello gin!后再次访问127.0.0.1:8080/会收到hello q1mi!的响应。 在不影响当前未处理完请求的同时完成了程序代码的替换，实现了优雅重启。 但是需要注意的是，此时程序的PID变化了，因为endless 是通过fork子进程处理新请求，待原进程处理完当前请求后再退出的方式实现优雅重启的。所以当你的项目是使用类似supervisor的软件管理进程时就不适用这种方式了。\n搭建一个通用的脚手架工具 v1.0 mysql.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package mysql import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; \u0026#34;github.com/jmoiron/sqlx\u0026#34; ) var db *sqlx.DB func Init() (err error) { dsn := fmt.Sprintf(\u0026#34;%s:%s@tcp(%s:%d)/%s?charset=utf8mb4\u0026amp;parseTime=True\u0026#34;, viper.GetString(\u0026#34;mysql.user\u0026#34;), viper.GetString(\u0026#34;mysql.password\u0026#34;), viper.GetString(\u0026#34;mysql.host\u0026#34;), viper.GetInt(\u0026#34;mysql.port\u0026#34;), viper.GetString(\u0026#34;mysql.dbName\u0026#34;), ) fmt.Println(dsn) db, err = sqlx.Connect(\u0026#34;mysql\u0026#34;, dsn) if err != nil { fmt.Printf(\u0026#34;mysql connect error,err : %v\\n\u0026#34;, err) return } db.SetMaxOpenConns(viper.GetInt(\u0026#34;mysql.maxOpen\u0026#34;)) db.SetMaxIdleConns(viper.GetInt(\u0026#34;mysql.maxIdle\u0026#34;)) return } func Close() { db.Close() } redis.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package redis import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/go-redis/redis\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) var rdb *redis.Client func Init() (err error) { rdb = redis.NewClient(\u0026amp;redis.Options{ Addr: fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, viper.GetString(\u0026#34;redis.host\u0026#34;), viper.GetInt(\u0026#34;redis.port\u0026#34;)), Password: viper.GetString(\u0026#34;redis.password\u0026#34;), DB: viper.GetInt(\u0026#34;redis.db\u0026#34;), PoolSize: viper.GetInt(\u0026#34;redis.poolSize\u0026#34;), //连接池大小 }) _, err = rdb.Ping().Result() if err != nil { fmt.Printf(\u0026#34;redis ping error,err: %v\u0026#34;, err) return } return } func Close() { rdb.Close() } log.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 package logger import ( \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/http/httputil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime/debug\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/natefinch/lumberjack\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;go.uber.org/zap/zapcore\u0026#34; ) func Init() (err error) { writer := getLoggerWriter( viper.GetString(\u0026#34;log.logName\u0026#34;), viper.GetInt(\u0026#34;log.max-size\u0026#34;), viper.GetInt(\u0026#34;log.max-age\u0026#34;), viper.GetInt(\u0026#34;log.max-backup\u0026#34;)) encoder := getEncoder() var l = new(zapcore.Level) err = l.UnmarshalText([]byte(viper.GetString(\u0026#34;log.level\u0026#34;))) if err != nil { return } core := zapcore.NewCore(encoder, writer, l) logger := zap.New(core, zap.AddCaller()) //替换zap库中的全局log对象 zap.ReplaceGlobals(logger) return } func getEncoder() zapcore.Encoder { encoderConfig := zap.NewProductionEncoderConfig() encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder return zapcore.NewConsoleEncoder(encoderConfig) } func getLoggerWriter(filePath string, maxSize int, maxAge int, maxBackUp int) zapcore.WriteSyncer { cfg := lumberjack.Logger{ Filename: filePath, MaxSize: maxSize, MaxBackups: maxBackUp, MaxAge: maxAge, Compress: false, } return zapcore.AddSync(\u0026amp;cfg) } //接受gin框架的默认日志 func GinLogger() gin.HandlerFunc { return func(c *gin.Context) { start := time.Now() path := c.Request.URL.Path query := c.Request.URL.RawQuery c.Next() //执行后面的中间件，然后计算cost cost := time.Since(start) zap.L().Info(path, zap.Int(\u0026#34;status\u0026#34;, c.Writer.Status()), zap.String(\u0026#34;method\u0026#34;, c.Request.Method), zap.String(\u0026#34;path\u0026#34;, path), zap.String(\u0026#34;query\u0026#34;, query), zap.String(\u0026#34;ip\u0026#34;, c.ClientIP()), zap.String(\u0026#34;user-agent\u0026#34;, c.Request.UserAgent()), zap.String(\u0026#34;errors\u0026#34;, c.Errors.ByType(gin.ErrorTypePrivate).String()), zap.Duration(\u0026#34;cost\u0026#34;, cost)) } } // GinRecovery recover掉项目可能出现的panic，并使用zap记录相关日志 func GinRecovery(stack bool) gin.HandlerFunc { return func(c *gin.Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \u0026#34;broken pipe\u0026#34;) || strings.Contains(strings.ToLower(se.Error()), \u0026#34;connection reset by peer\u0026#34;) { brokenPipe = true } } } httpRequest, _ := httputil.DumpRequest(c.Request, false) if brokenPipe { zap.L().Error(c.Request.URL.Path, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) // If the connection is dead, we can\u0026#39;t write a status to it. c.Error(err.(error)) // nolint: errcheck c.Abort() return } if stack { zap.L().Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), zap.String(\u0026#34;stack\u0026#34;, string(debug.Stack())), ) } else { zap.L().Error(\u0026#34;[Recovery from panic]\u0026#34;, zap.Any(\u0026#34;error\u0026#34;, err), zap.String(\u0026#34;request\u0026#34;, string(httpRequest)), ) } c.AbortWithStatus(http.StatusInternalServerError) } }() c.Next() } } route.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package route import ( \u0026#34;comman_web_structure/logger\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func SetUp() *gin.Engine { r := gin.New() r.Use(logger.GinLogger(), logger.GinRecovery(true)) r.GET(\u0026#34;/\u0026#34;, func(context *gin.Context) { context.String(http.StatusOK, \u0026#34;hello\u0026#34;) }) return r } setting.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package settings import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/fsnotify/fsnotify\u0026#34; \u0026#34;github.com/spf13/viper\u0026#34; ) func Init() (err error) { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;yaml\u0026#34;) viper.AddConfigPath(\u0026#34;./settings\u0026#34;) err = viper.ReadInConfig() if err != nil { fmt.Printf(\u0026#34;read error,err:%v\\n\u0026#34;, err) return } viper.WatchConfig() viper.OnConfigChange(func(in fsnotify.Event) { fmt.Printf(\u0026#34;配置文件修改了..\u0026#34;) }) return } v2.0(将配置信息写道结构体) 优化后的settings\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 var Conf = new(AppConfig) type AppConfig struct { Name string `mapstructure:\u0026#34;name\u0026#34;` Port string `mapstructure:\u0026#34;port\u0026#34;` Mode string `mapstructure:\u0026#34;mode\u0026#34;` *MysqlConfig `mapstructure:\u0026#34;mysql\u0026#34;` *RedisConfig `mapstructure:\u0026#34;redis\u0026#34;` *LoggerConfig `mapstructure:\u0026#34;log\u0026#34;` } type MysqlConfig struct { Host string `mapstructure:\u0026#34;host\u0026#34;` Port int `mapstructure:\u0026#34;port\u0026#34;` User string `mapstructure:\u0026#34;user\u0026#34;` Password string `mapstructure:\u0026#34;password\u0026#34;` DbName string `mapstructure:\u0026#34;dbName\u0026#34;` MaxOpen int `mapstructure:\u0026#34;maxOpen\u0026#34;` MaxIdle int `mapstructure:\u0026#34;maxIdle\u0026#34;` } type RedisConfig struct { Host string `mapstructure:\u0026#34;host\u0026#34;` Port int `mapstructure:\u0026#34;port\u0026#34;` Password string `mapstructure:\u0026#34;password\u0026#34;` Db int `mapstructure:\u0026#34;db\u0026#34;` PoolSize int `mapstructure:\u0026#34;poolSize\u0026#34;` } type LoggerConfig struct { Level string `mapstructure:\u0026#34;level\u0026#34;` LogName string `mapstructure:\u0026#34;logName\u0026#34;` MaxSize int `mapstructure:\u0026#34;max-size\u0026#34;` MaxAge int `mapstructure:\u0026#34;max-age\u0026#34;` MaxBackup int `mapstructure:\u0026#34;max-backup\u0026#34;` } func Init() (err error) { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;yaml\u0026#34;) viper.AddConfigPath(\u0026#34;./settings\u0026#34;) err = viper.ReadInConfig() if err != nil { fmt.Printf(\u0026#34;read error,err:%v\\n\u0026#34;, err) return } if err = viper.Unmarshal(Conf); err != nil { fmt.Printf(\u0026#34;unMarshal error, err : %v\\n\u0026#34;, err) } viper.WatchConfig() viper.OnConfigChange(func(in fsnotify.Event) { fmt.Printf(\u0026#34;配置文件修改了..\u0026#34;) }) return } v3.0(用命令行指定文件) 用系统内置的os\n1 2 3 4 5 6 7 8 9 if len(os.Args) \u0026lt; 2 { fmt.Println(\u0026#34;need config file..\u0026#34;) return } //1.加载配置 通过args if err := settings.Init(os.Args[1]); err != nil { fmt.Printf(\u0026#34;init settings error,err:%v\u0026#34;, err) return } 用第三方库flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { //定义命令行参数方式1 var name string var age int var married bool var delay time.Duration flag.StringVar(\u0026amp;name, \u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;, \u0026#34;姓名\u0026#34;) flag.IntVar(\u0026amp;age, \u0026#34;age\u0026#34;, 18, \u0026#34;年龄\u0026#34;) flag.BoolVar(\u0026amp;married, \u0026#34;married\u0026#34;, false, \u0026#34;婚否\u0026#34;) flag.DurationVar(\u0026amp;delay, \u0026#34;d\u0026#34;, 0, \u0026#34;延迟的时间间隔\u0026#34;) //解析命令行参数 flag.Parse() fmt.Println(name, age, married, delay) //返回命令行参数后的其他参数 fmt.Println(flag.Args()) //返回命令行参数后的其他参数个数 fmt.Println(flag.NArg()) //返回使用的命令行参数个数 fmt.Println(flag.NFlag()) } 项目搭建 分布式ID 雪花算法 如何使用 1 go get github.com/bwmarrin/snowflake 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func Init(startTime string, machineId int64) (err error) { var t time.Time //先将当前时间格式转换 t, err = time.Parse(\u0026#34;2006-01-02\u0026#34;, startTime) if err != nil { return } snowflake.Epoch = t.UnixNano() / 100000 node, err = snowflake.NewNode(machineId) return } func getId() int64 { return node.Generate().Int64() } 注册逻辑 在controller层，一般做参数校验已经通过service进行业务处理最后返回。\n普通的参数判断\n1 2 3 4 5 6 if len(par.Username) == 0 || len(par.Password) == 0 || len(par.RePassword) == 0 || par.RePassword != par.Password { zap.L().Error(\u0026#34;Signup with invalid param\u0026#34;) context.JSON(http.StatusOK, gin.H{ \u0026#34;msg\u0026#34;: \u0026#34;请求参数有误！\u0026#34;, }) } 用第三方库进行参数校验 在web开发中一个不可避免的环节就是对请求参数进行校验，通常我们会在代码中定义与请求参数相对应的模型（结构体），借助模型绑定快捷地解析请求中的参数，例如 gin 框架中的Bind和ShouldBind系列方法。本文就以 gin 框架的请求参数校验为例，介绍一些validator库的实用技巧。\ngin框架使用github.com/go-playground/validator进行参数校验，目前已经支持github.com/go-playground/validator/v10了，我们需要在定义结构体时使用 binding tag标识相关校验规则，可以查看validator文档查看支持的所有 tag。\n用一个简单的binding即可校验\nvalidator返回错误信息的国际化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package controller import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/gin-gonic/gin/binding\u0026#34; \u0026#34;github.com/go-playground/locales/en\u0026#34; \u0026#34;github.com/go-playground/locales/zh\u0026#34; ut \u0026#34;github.com/go-playground/universal-translator\u0026#34; \u0026#34;github.com/go-playground/validator/v10\u0026#34; enTranslations \u0026#34;github.com/go-playground/validator/v10/translations/en\u0026#34; zhTranslations \u0026#34;github.com/go-playground/validator/v10/translations/zh\u0026#34; ) // 定义一个全局翻译器T var trans ut.Translator // InitTrans 初始化翻译器 func InitTrans(locale string) (err error) { // 修改gin框架中的Validator引擎属性，实现自定制 if v, ok := binding.Validator.Engine().(*validator.Validate); ok { // 注册一个获取json tag的自定义方法 v.RegisterTagNameFunc(func(fld reflect.StructField) string { name := strings.SplitN(fld.Tag.Get(\u0026#34;json\u0026#34;), \u0026#34;,\u0026#34;, 2)[0] if name == \u0026#34;-\u0026#34; { return \u0026#34;\u0026#34; } return name }) zhT := zh.New() // 中文翻译器 enT := en.New() // 英文翻译器 // 第一个参数是备用（fallback）的语言环境 // 后面的参数是应该支持的语言环境（支持多个） // uni := ut.New(zhT, zhT) 也是可以的 uni := ut.New(enT, zhT, enT) // locale 通常取决于 http 请求头的 \u0026#39;Accept-Language\u0026#39; var ok bool // 也可以使用 uni.FindTranslator(...) 传入多个locale进行查找 trans, ok = uni.GetTranslator(locale) if !ok { return fmt.Errorf(\u0026#34;uni.GetTranslator(%s) failed\u0026#34;, locale) } // 注册翻译器 switch locale { case \u0026#34;en\u0026#34;: err = enTranslations.RegisterDefaultTranslations(v, trans) case \u0026#34;zh\u0026#34;: err = zhTranslations.RegisterDefaultTranslations(v, trans) default: err = enTranslations.RegisterDefaultTranslations(v, trans) } return } return } //去除提示信息的结构体 func removeTopStruct(fields map[string]string) map[string]string { res := map[string]string{} for field, err := range fields { res[field[strings.Index(field, \u0026#34;.\u0026#34;)+1:]] = err } return res } 日志输出到控制台和文件（dev环境下方便调试） 1 2 3 4 5 6 7 8 9 10 11 if settings.Conf.Mode == \u0026#34;dev\u0026#34; { consoleEncoder := zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig()) //通过tee，得到了两个输出 core = zapcore.NewTee( zapcore.NewCore(encoder, writer, l), //向终端输出 zapcore.NewCore(consoleEncoder, zapcore.Lock(os.Stdout), zapcore.DebugLevel), ) } else { core = zapcore.NewCore(encoder, writer, l) } 通过配置文件的mode，获得当前的开发环境，然后如果是dev，就通过tee得到两个core，一个输出到文件，一个输出到控制台，方便调试。\n封装返回的json 我截取一段 现在的代码，大家可以发现返回的时候都要调用context.json很麻烦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func LoginUser(context *gin.Context) { var p = new(model.LoginParam) if err := context.ShouldBindJSON(p); err != nil { errors, ok := err.(validator.ValidationErrors) zap.L().Error(\u0026#34;login with invalid json\u0026#34;, zap.Error(err)) if ok { context.JSON(http.StatusOK, gin.H{ \u0026#34;msg\u0026#34;: removeTopStruct(errors.Translate(trans)), }) } else { context.JSON(http.StatusOK, gin.H{ \u0026#34;msg\u0026#34;: err.Error(), }) } return } if err := service.Login(p); err != nil { zap.L().Error(\u0026#34;login error\u0026#34;, zap.Error(err)) context.JSON(http.StatusOK, gin.H{ \u0026#34;msg\u0026#34;: \u0026#34;用户名或者密码错误\u0026#34;, }) return } context.JSON(http.StatusOK, gin.H{ \u0026#34;msg\u0026#34;: \u0026#34;登陆成功\u0026#34;, }) } 我们可以将返回响应封装为一个函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package controller import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type Response struct { Code ResCode `json:\u0026#34;code\u0026#34;` Msg interface{} `json:\u0026#34;msg\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } func ResponseError(code ResCode, c *gin.Context) { c.JSON(http.StatusOK, \u0026amp;Response{ Code: code, Msg: Msg(code), Data: nil, }) } func ResponseErrorWithMsg(code ResCode, c *gin.Context, msg interface{}) { c.JSON(http.StatusOK, \u0026amp;Response{ Code: code, Msg: msg, Data: nil, }) } func ResponseSuccess(c *gin.Context, data interface{}) { c.JSON(http.StatusOK, \u0026amp;Response{ Code: CodeSuccess, Msg: Msg(CodeSuccess), Data: data, }) } 对应的Code类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package controller type ResCode int64 const ( CodeSuccess ResCode = 1000 + iota CodeInvalidParam CodeUserExist CodeUserNotExist CodeInvalidPassword CodeServeBusy ) var codeMap = map[ResCode]string{ CodeSuccess: \u0026#34;请求成功\u0026#34;, CodeInvalidParam: \u0026#34;请求参数异常\u0026#34;, CodeUserExist: \u0026#34;用户已存在\u0026#34;, CodeUserNotExist: \u0026#34;用户不存在\u0026#34;, CodeInvalidPassword: \u0026#34;密码错误\u0026#34;, CodeServeBusy: \u0026#34;服务器繁忙\u0026#34;, } func Msg(code ResCode) string { s, ok := codeMap[code] if !ok { return codeMap[CodeServeBusy] } else { return s } } 将errors.New封装成对象，方便controller判断 这些错误我们的controller不好判断，最好把它换成下图这样\n改造后，变得优雅了许多\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package controller import ( \u0026#34;comman_web_structure/dao/mysql\u0026#34; \u0026#34;comman_web_structure/model\u0026#34; \u0026#34;comman_web_structure/service\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;github.com/go-playground/validator/v10\u0026#34; \u0026#34;go.uber.org/zap\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func SingUpUser(context *gin.Context) { var par model.SignUpParam if err := context.ShouldBindJSON(\u0026amp;par); err != nil { zap.L().Error(\u0026#34;Signup with invalid json\u0026#34;, zap.Error(err)) errors, ok := err.(validator.ValidationErrors) if !ok { ResponseError(CodeInvalidParam, context) return } else { ResponseErrorWithMsg(CodeInvalidParam, context, removeTopStruct(errors.Translate(trans))) } return } if err := service.SignUp(\u0026amp;par); err != nil { zap.L().Error(\u0026#34;Signup error\u0026#34;, zap.Error(err)) if errors.Is(err, mysql.ErrorUserExist) { ResponseError(CodeUserExist, context) return } ResponseError(CodeServeBusy, context) return } ResponseSuccess(context, nil) } func LoginUser(context *gin.Context) { var p = new(model.LoginParam) if err := context.ShouldBindJSON(p); err != nil { errors, ok := err.(validator.ValidationErrors) zap.L().Error(\u0026#34;login with invalid json\u0026#34;, zap.Error(err)) if ok { ResponseErrorWithMsg(CodeInvalidParam, context, removeTopStruct(errors.Translate(trans))) } else { ResponseError(CodeInvalidParam, context) } return } if err := service.Login(p); err != nil { zap.L().Error(\u0026#34;login error\u0026#34;, zap.Error(err)) if errors.Is(err, mysql.ErrorUserNotExist) { ResponseError(CodeUserNotExist, context) } else if errors.Is(err, mysql.ErrorUserPasswordWrong) { ResponseError(CodeInvalidPassword, context) } else { ResponseError(CodeServeBusy, context) } return } ResponseSuccess(context,nil) } 利用Jwt的token进行登录 一般还会有另一种中方案：Cookie + Session，但是会有一点风险，因为会有安全的危险，假如有一个钓鱼网站得到了你的cookie，就会发生安全问题。并且session是需要存储在服务器端的。\n1 go get -u github.com/dgrijalva/jwt-go 通过token进行校验 校验方法我们会放在中间件中，若某个接口需要登陆，可以直接将中间键的方法放到路由里面即可。\n方法大概是取出头部的token，对token校验，若出错则返回错误，否则会将用户的id放到context中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func JWTAuthMiddleware() func(c *gin.Context) { return func(c *gin.Context) { // 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI // 这里假设Token放在Header的Authorization中，并使用Bearer开头 // 这里的具体实现方式要依据你的实际业务情况决定 authHeader := c.Request.Header.Get(\u0026#34;Authorization\u0026#34;) if authHeader == \u0026#34;\u0026#34; { c.JSON(http.StatusOK, gin.H{ \u0026#34;code\u0026#34;: 2003, \u0026#34;msg\u0026#34;: \u0026#34;请求头中auth为空\u0026#34;, }) c.Abort() return } // 按空格分割 parts := strings.SplitN(authHeader, \u0026#34; \u0026#34;, 2) if !(len(parts) == 2 \u0026amp;\u0026amp; parts[0] == \u0026#34;Bearer\u0026#34;) { controller.ResponseError(controller.CodeEmptyRequestHeader, c) c.Abort() return } // parts[1]是获取到的tokenString，我们使用之前定义好的解析JWT的函数来解析它 mc, err := jwt.ParseToken(parts[1]) if err != nil { controller.ResponseError(controller.CodeInvalidAuth, c) c.Abort() return } // 将当前请求的username信息保存到请求的上下文c上 c.Set(ContextUserName, mc.Username) c.Set(ContextUserID, mc.UserId) c.Next() // 后续的处理函数可以用过c.Get(\u0026#34;username\u0026#34;)来获取当前请求的用户信息 } } 但是现在我去go build，他却告诉我有循环引用，啥情况？\n首先分析一下，下面的日志告诉我们是controller和middle发生循环引用了。\nrequest是在controller层的，他用于解析出request头部中头部所带的payload，再看看鉴权方法是存在与middle包的。\n明确了这两点来看看代码\n（middle-\u0026gt;controller）\n(controller-\u0026gt;middle)\n解决方法很简单，我们不要让controller引用middle的id就可以了，把id放在controller层\n现在就变成了controlle不引用，middle-\u0026gt;controller,不存在循环引用。\n结果：\nrefresh token 以前在java项目也用过，双令牌，即时间长的令牌如果存在，会给用户一个新的access token，如果不存在那只能重新登录，然后去申请双令牌了。\n如何限制一台电脑只能登录一个账号 首先，我们知道当我们发布token的时候，一定一定，账号登录是没有问题的，那么我们如何来保存token的唯一性呢？（一个账号只能登录一个设备，换句话说同一时间只能存在一个有效token）\n我们可以将token存到redis，并且存储userId和token对应，由于redis的string，key是一定要唯一的，我们可以拿userId为key，token为val，在调用接口进行认证的时候，先取出token中的userId，再去redis里面取出token，进行对比，如果token不一致说明该账号有两个不同机器正在登陆，以redis为准即可。\n为go项目编写make file | Golang\n|总阅读量：11560次\n借助Makefile我们在编译过程中不再需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程。\nmake介绍 make是一个构建自动化工具，会在当前目录下寻找Makefile或makefile文件。如果存在相应的文件，它就会依据其中定义好的规则完成构建任务。\nMakefile介绍 我们可以把Makefile简单理解为它定义了一个项目文件的编译规则。借助Makefile我们在编译过程中不再需要每次手动输入编译的命令和编译的参数，可以极大简化项目编译过程。同时使用Makefile也可以在项目中确定具体的编译规则和流程，很多开源项目中都会定义Makefile文件。\n本文不会详细介绍Makefile的各种规则，只会给出Go项目中常用的Makefile示例。关于Makefile的详细内容推荐阅读Makefile教程。\n规则概述 Makefile由多条规则组成，每条规则主要由两个部分组成，分别是依赖的关系和执行的命令。\n其结构如下所示：\n1 2 3 4 [target] ... : [prerequisites] ... \u0026lt;tab\u0026gt;[command] ... ... 其中：\ntargets：规则的目标 prerequisites：可选的要生成 targets 需要的文件或者是目标。 command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。 举个例子：\n1 2 build: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o xx 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 .PHONY: all build run gotool clean help BINARY=\u0026#34;bluebell\u0026#34; all: gotool build build: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o ${BINARY} run: @go run ./ gotool: go fmt ./ go vet ./ clean: @if [ -f ${BINARY} ] ; then rm ${BINARY} ; fi help: @echo \u0026#34;make - 格式化 Go 代码, 并编译生成二进制文件\u0026#34; @echo \u0026#34;make build - 编译 Go 代码, 生成二进制文件\u0026#34; @echo \u0026#34;make run - 直接运行 Go 代码\u0026#34; @echo \u0026#34;make clean - 移除二进制文件和 vim swap files\u0026#34; @echo \u0026#34;make gotool - 运行 Go 工具 \u0026#39;fmt\u0026#39; and \u0026#39;vet\u0026#39;\u0026#34; 其中：\nBINARY=\u0026quot;bluebell\u0026quot;是定义变量。 .PHONY用来定义伪目标。不创建目标文件，而是去执行这个目标下面的命令。 air（大大提高开发效率） go get -u github.com/cosmtrek/air\nGo内存对齐 这两个结构体虽然属性一样，但是最后new出来一个对象，占用内存是不一样的，因为内存对齐。\n1 2 3 4 5 6 7 8 9 10 11 type s1 struct{ i1 int8 i2 int64 i3 int32 } type s1 struct{ i1 int8 i3 int32 i2 int64 } 对查询结果的优化 当我第一次编写接口，发现有一个问题，当我返回帖子的细节的时候，由于数据库及采用的外键关联，所以返回的数据并不是作者名字，而是作者ID，这样非常不友好，我想把关联信息也一并返回。\n遇到的问题：返回整个结果的时候发生空指针。。（粗心了）\n可以看到p是没有初始化的，所以我们new一下就好了。查出来就没啥毛病\n这里会发现，数据其实有点挤在一起，看着不舒服，我们想把社区的放一边，作者放一边，怎么办呢？\n​\t改造一下\n舒服多了\n分页查询 从前端后的页码和size即可。\n1 2 3 4 5 6 func GetPostList(offset int64, size int64) (list []*model.Post, err error) { list = make([]*model.Post, 0, size) sqlStr := \u0026#34;select post_id,author_id,community_id,title,content,create_time from post limit ?,?\u0026#34; err = db.Select(\u0026amp;list, sqlStr, offset, size) return list, err } 后端用select查询数据库封装到切片里面返回就好了。\n其实我们可能会有很多需要分页的项目，所以我们为了避免重复书写代码，可以将获得页码的代码给抽出来。放到Request.go中\n解决id发送给前端失真的问题 由于go后端这边的id用的为int64类型，数据大小在2^-63 + 1~2^63 - 1,但是JS的Number数据类型的数据大小会在2^-53 + 1~2^53 - 1.会导致数据精度有问题。\n我们可以将这个值变成string类型传输即可。\n但是由于前端会传给我们后端一个字符串，如果结构体仍然用以前的结构体，如下\n1 2 3 4 type Community struct { ID int64 `json:\u0026#34;community_id\u0026#34;` Name string `json:\u0026#34;community_name\u0026#34;` } 是无法调用Unmarshal的，因为前端发的是string，go这边用的int64，我们稍微修改一下就可以了\n1 2 3 4 type Community struct { ID int64 `json:\u0026#34;community_id,string\u0026#34;` Name string `json:\u0026#34;community_name\u0026#34;` } 更多golang json的用法：https://www.liwenzhou.com/posts/Go/json_tricks_in_go/\n投票功能 我们在写投票功能之前，首先明确我们想实现什么功能，首先得记录每个用户投的是赞成票还是反对票，其次我们想实现一个关于时间和，热度的排行榜。\n我们可以利用redis中的Zset来实现，对于记录用户我们可以为每一个帖子做一个zset，key是某一个key+帖子ID，里面存储的是userId对应是否投票（-1：投反对，1投赞成）\n对于排行榜就很简单，直接对应的帖子给上响应的权值即可。\n我们如何计算热度呢，我们这里比较简单，赞成票就+432，反对就-432。\n将可能发生的情况穷举出来：\ndb:1 request:1 0 abs = 0\ndb:1 request:0 -432 abs = 1\ndb:1 request:-1 -432 * 2 abs = 2\ndb:0 request:1 432 abs = 1\ndb:0 request:0 0 abs = 0\ndb:0 request:-1 -432 abs = 1\ndb:-1 request:1 + 432* 2 abs = 2\ndb:-1 request:-1 0 abs = 0\ndb:-1 request:0 + 432 abs = 0\n我们可以通过abs来判断当前应该改变多少积分\n可以看到当abs=0积分不变，abs=1积分变化432(+或者-)，当abs=2积分变化2*432（+或者-）\n又可以发现当request \u0026gt; 0 就是+，否则为-\n现在逻辑就很清晰。\n那么问题来了，一开始我们好像并没有排行榜所需的那两个zset，我们需要创建zset\n那再看，其实这应该是一个原子性的操作，不能一个成功一个失败，所以应该放到事务里面，上面曾讲过事务pipeline，太完美了。\n会看到dao层的投票功能，里面会对用户投票记录和分数记录，这两个也是应该是原子性的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func VoteForPost(userId, postId string, flag float64) (err error) { score, err := rdb.ZScore(getKey(TimeZSet), postId).Result() if err != nil { return err } if float64(time.Now().Unix())-score \u0026gt; weekUnix { return ErrorTimeExpire } //得到该用户在redis中是否投票过 score = rdb.ZScore(getKey(FlagZSet+postId), userId).Val() dif := math.Abs(score - flag) pipeline := rdb.TxPipeline() if score \u0026lt; flag { pipeline.IncrBy(getKey(ScoreZSet), int64(dif*1*perFlagScore)) } else { pipeline.IncrBy(getKey(ScoreZSet), int64(dif*-1*perFlagScore)) } //更新记录用户投票的zset if flag == 0 { pipeline.ZRem(getKey(FlagZSet+postId), userId) } else { pipeline.ZAdd(getKey(FlagZSet+postId), redis.Z{ Score: flag, Member: userId, }) } _, err = pipeline.Exec() return } swagger接口文档 如何得到：\ngo get -u github.com/swaggo/swag/cmd/swag\n想要使用gin-swagger为你的代码自动生成接口文档，一般需要下面三个步骤：\n按照swagger要求给接口代码添加声明式注释，具体参照声明式注释格式。 使用swag工具扫描代码自动生成API接口文档数据 使用gin-swagger渲染在线接口文档页面 第一步：添加注释 在程序入口main函数上以注释的方式写下项目相关介绍信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main // @title 这里写标题 // @version 1.0 // @description 这里写描述信息 // @termsOfService http://swagger.io/terms/ // @contact.name 这里写联系人信息 // @contact.url http://www.swagger.io/support // @contact.email support@swagger.io // @license.name Apache 2.0 // @license.url http://www.apache.org/licenses/LICENSE-2.0.html // @host 这里写接口服务的host // @BasePath 这里写base path func main() { r := gin.New() // liwenzhou.com ... r.Run() } 在你代码中处理请求的接口函数（通常位于controller层）按如下方式写上注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // GetPostListHandler2 升级版帖子列表接口 // @Summary 升级版帖子列表接口 // @Description 可按社区按时间或分数排序查询帖子列表接口 // @Tags 帖子相关接口 // @Accept application/json // @Produce application/json // @Param Authorization header string false \u0026#34;Bearer 用户令牌\u0026#34; // @Param object query models.ParamPostList false \u0026#34;查询参数\u0026#34; // @Security ApiKeyAuth // @Success 200 {object} _ResponsePostList // @Router /posts2 [get] func GetPostListHandler2(c *gin.Context) { // GET请求参数(query string)：/api/v1/posts2?page=1\u0026amp;size=10\u0026amp;order=time // 初始化结构体时指定初始参数 p := \u0026amp;models.ParamPostList{ Page: 1, Size: 10, Order: models.OrderTime, } if err := c.ShouldBindQuery(p); err != nil { zap.L().Error(\u0026#34;GetPostListHandler2 with invalid params\u0026#34;, zap.Error(err)) ResponseError(c, CodeInvalidParam) return } data, err := logic.GetPostListNew(p) // 获取数据 if err != nil { zap.L().Error(\u0026#34;logic.GetPostList() failed\u0026#34;, zap.Error(err)) ResponseError(c, CodeServerBusy) return } ResponseSuccess(c, data) // 返回响应 } 上面注释中参数类型使用了object，models.ParamPostList具体定义如下：\n1 2 3 4 5 6 7 8 9 // bluebell/models/params.go // ParamPostList 获取帖子列表query string参数 type ParamPostList struct { CommunityID int64 `json:\u0026#34;community_id\u0026#34; form:\u0026#34;community_id\u0026#34;` // 可以为空 Page int64 `json:\u0026#34;page\u0026#34; form:\u0026#34;page\u0026#34; example:\u0026#34;1\u0026#34;` // 页码 Size int64 `json:\u0026#34;size\u0026#34; form:\u0026#34;size\u0026#34; example:\u0026#34;10\u0026#34;` // 每页数据量 Order string `json:\u0026#34;order\u0026#34; form:\u0026#34;order\u0026#34; example:\u0026#34;score\u0026#34;` // 排序依据 } 响应数据类型也使用的object，我个人习惯在controller层专门定义一个docs_models.go文件来存储文档中使用的响应数据model。\n1 2 3 4 5 6 7 8 // bluebell/controller/docs_models.go // _ResponsePostList 帖子列表接口响应数据 type _ResponsePostList struct { Code ResCode `json:\u0026#34;code\u0026#34;` // 业务响应状态码 Message string `json:\u0026#34;message\u0026#34;` // 提示信息 Data []*models.ApiPostDetail `json:\u0026#34;data\u0026#34;` // 数据 } 第二步：生成接口文档数据 编写完注释后，使用以下命令安装swag工具：\n1 go get -u github.com/swaggo/swag/cmd/swag 在项目根目录执行以下命令，使用swag工具生成接口文档数据。\n1 swag init 执行完上述命令后，如果你写的注释格式没问题，此时你的项目根目录下会多出一个docs文件夹。\n1 2 3 4 ./docs ├── docs.go ├── swagger.json └── swagger.yaml 第三步：引入gin-swagger渲染文档数据 然后在项目代码中注册路由的地方按如下方式引入gin-swagger相关内容：\n1 2 3 4 5 6 7 8 9 10 import ( // liwenzhou.com ... _ \u0026#34;bluebell/docs\u0026#34; // 千万不要忘了导入把你上一步生成的docs gs \u0026#34;github.com/swaggo/gin-swagger\u0026#34; \u0026#34;github.com/swaggo/gin-swagger/swaggerFiles\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) 注册swagger api相关路由\n1 r.GET(\u0026#34;/swagger/*any\u0026#34;, gs.WrapHandler(swaggerFiles.Handler)) 把你的项目程序运行起来，打开浏览器访问http://localhost:8080/swagger/index.html就能看到Swagger 2.0 Api文档了。\ngin-swagger同时还提供了DisablingWrapHandler函数，方便我们通过设置某些环境变量来禁用Swagger。例如：\n1 r.GET(\u0026#34;/swagger/*any\u0026#34;, gs.DisablingWrapHandler(swaggerFiles.Handler, \u0026#34;NAME_OF_ENV_VARIABLE\u0026#34;)) 此时如果将环境变量NAME_OF_ENV_VARIABLE设置为任意值，则/swagger/*any将返回404响应，就像未指定路由时一样。\n这是Go语言单元测试从零到溜系列教程的第0篇，主要讲解在Go语言中如何编写单元测试以及介绍了表格驱动测试、回归测试和单元测试中常用的断言工具。\nGo语言单元测试从零到溜系列共7篇，本文是第0篇，介绍了Go语言单元测试的基础内容。本篇部分内容基于我之前写过的那篇《Go语言基础之单元测试》，内容略有删改。特别是由于篇幅限制移除了基准测试相关内容，想了解基准测试/性能测试的同学可以点击上文链接查看。\n《Go单测从零到溜系列》的示例代码已上传至Github，点击👉🏻https://github.com/Q1mi/golang-unit-test-demo 查看完整源代码。\nGo语言单元测试 go test工具 Go语言中的测试依赖go test命令。编写测试代码和编写普通的Go代码过程是类似的，并不需要学习新的语法、规则或工具。\ngo test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。\n在*_test.go文件中有三种类型的函数，单元测试函数、基准测试函数和示例函数。\n类型 格式 作用 测试函数 函数名前缀为Test 测试程序的一些逻辑行为是否正确 基准函数 函数名前缀为Benchmark 测试函数的性能 示例函数 函数名前缀为Example 为文档提供示例文档 go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。\n单元测试函数 格式 每个测试函数必须导入testing包，测试函数的基本格式（签名）如下：\n1 2 3 func TestName(t *testing.T){ // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头，举几个例子：\n1 2 3 func TestAdd(t *testing.T){ ... } func TestSum(t *testing.T){ ... } func TestLog(t *testing.T){ ... } 其中参数t用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (c *T) Cleanup(func()) func (c *T) Error(args ...interface{}) func (c *T) Errorf(format string, args ...interface{}) func (c *T) Fail() func (c *T) FailNow() func (c *T) Failed() bool func (c *T) Fatal(args ...interface{}) func (c *T) Fatalf(format string, args ...interface{}) func (c *T) Helper() func (c *T) Log(args ...interface{}) func (c *T) Logf(format string, args ...interface{}) func (c *T) Name() string func (c *T) Skip(args ...interface{}) func (c *T) SkipNow() func (c *T) Skipf(format string, args ...interface{}) func (c *T) Skipped() bool func (c *T) TempDir() string 单元测试示例 就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任意东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。\n接下来，我们在base_demo包中定义了一个Split函数，具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // base_demo/split.go package base_demo import \u0026#34;strings\u0026#34; // Split 把字符串s按照给定的分隔符sep进行分割返回字符串切片 func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u0026gt; -1 { result = append(result, s[:i]) s = s[i+1:] i = strings.Index(s, sep) } result = append(result, s) return } 在当前目录下，我们创建一个split_test.go的测试文件，并定义一个测试函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // split/split_test.go package split import ( \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数 got := Split(\u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;) // 程序输出的结果 want := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} // 期望的结果 if !reflect.DeepEqual(want, got) { // 因为slice不能比较直接，借助反射包中的方法比较 t.Errorf(\u0026#34;expected:%v, got:%v\u0026#34;, want, got) // 测试失败输出错误提示 } } 此时split这个包中的文件如下：\n1 2 3 4 ❯ ls -l total 16 -rw-r--r-- 1 liwenzhou staff 408 4 29 15:50 split.go -rw-r--r-- 1 liwenzhou staff 466 4 29 16:04 split_test.go 在当前路径下执行go test命令，可以看到输出结果如下：\n1 2 3 ❯ go test PASS ok golang-unit-test-demo/base_demo 0.005s go test -v 一个测试用例有点单薄，我们再编写一个测试使用多个字符切割字符串的例子，在split_test.go中添加如下测试函数：\n1 2 3 4 5 6 7 func TestSplitWithComplexSep(t *testing.T) { got := Split(\u0026#34;abcd\u0026#34;, \u0026#34;bc\u0026#34;) want := []string{\u0026#34;a\u0026#34;, \u0026#34;d\u0026#34;} if !reflect.DeepEqual(want, got) { t.Errorf(\u0026#34;expected:%v, got:%v\u0026#34;, want, got) } } 现在我们有多个测试用例了，为了能更好的在输出结果中看到每个测试用例的执行情况，我们可以为go test命令添加-v参数，让它输出完整的测试结果。\n1 2 3 4 5 6 7 8 9 ❯ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestSplitWithComplexSep split_test.go:20: expected:[a d], got:[a cd] --- FAIL: TestSplitWithComplexSep (0.00s) FAIL exit status 1 FAIL golang-unit-test-demo/base_demo 0.009s 从上面的输出结果我们能清楚的看到是TestSplitWithComplexSep这个测试用例没有测试通过。\ngo test -run 单元测试的结果表明split函数的实现并不可靠，没有考虑到传入的sep参数是多个字符的情况，下面我们来修复下这个Bug：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package base_demo import \u0026#34;strings\u0026#34; // Split 把字符串s按照给定的分隔符sep进行分割返回字符串切片 func Split(s, sep string) (result []string) { i := strings.Index(s, sep) for i \u0026gt; -1 { result = append(result, s[:i]) s = s[i+len(sep):] // 这里使用len(sep)获取sep的长度 i = strings.Index(s, sep) } result = append(result, s) return } 在执行go test命令的时候可以添加-run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被go test命令执行。\n例如通过给go test添加-run=Sep参数来告诉它本次测试只运行TestSplitWithComplexSep这个测试用例：\n1 2 3 4 5 ❯ go test -run=Sep -v === RUN TestSplitWithComplexSep --- PASS: TestSplitWithComplexSep (0.00s) PASS ok golang-unit-test-demo/base_demo 0.010s 最终的测试结果表情我们成功修复了之前的Bug。\n回归测试 我们修改了代码之后仅仅执行那些失败的测试用例或新引入的测试用例是错误且危险的，正确的做法应该是完整运行所有的测试用例，保证不会因为修改代码而引入新的问题。\n1 2 3 4 5 6 7 ❯ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestSplitWithComplexSep --- PASS: TestSplitWithComplexSep (0.00s) PASS ok golang-unit-test-demo/base_demo 0.011s 测试结果表明我们的单元测试全部通过。\n通过这个示例我们可以看到，有了单元测试就能够在代码改动后快速进行回归测试，极大地提高开发效率并保证代码的质量。\n跳过某些测试用例 为了节省时间支持在单元测试时跳过某些耗时的测试用例。\n1 2 3 4 5 6 func TestTimeConsuming(t *testing.T) { if testing.Short() { t.Skip(\u0026#34;short模式下会跳过该测试用例\u0026#34;) } ... } 当执行go test -short时就不会执行上面的TestTimeConsuming测试用例。\n子测试 在上面的示例中我们为每一个测试数据编写了一个测试函数，而通常单元测试中需要多组测试数据保证测试的效果。Go1.7+中新增了子测试，支持在测试函数中使用t.Run执行一组测试用例，这样就不需要为不同的测试数据定义多个测试函数了。\n1 2 3 4 5 func TestXXX(t *testing.T){ t.Run(\u0026#34;case1\u0026#34;, func(t *testing.T){...}) t.Run(\u0026#34;case2\u0026#34;, func(t *testing.T){...}) t.Run(\u0026#34;case3\u0026#34;, func(t *testing.T){...}) } 表格驱动测试 介绍 表格驱动测试不是工具、包或其他任何东西，它只是编写更清晰测试的一种方式和视角。\n编写好的测试并非易事，但在许多情况下，表格驱动测试可以涵盖很多方面：表格里的每一个条目都是一个完整的测试用例，包含输入和预期结果，有时还包含测试名称等附加信息，以使测试输出易于阅读。\n使用表格驱动测试能够很方便的维护多个测试用例，避免在编写单元测试时频繁的复制粘贴。\n表格驱动测试的步骤通常是定义一个测试用例表格，然后遍历表格，并使用t.Run对每个条目执行必要的测试。\n示例 官方标准库中有很多表格驱动测试的示例，例如fmt包中便有如下测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var flagtests = []struct { in string out string }{ {\u0026#34;%a\u0026#34;, \u0026#34;[%a]\u0026#34;}, {\u0026#34;%-a\u0026#34;, \u0026#34;[%-a]\u0026#34;}, {\u0026#34;%+a\u0026#34;, \u0026#34;[%+a]\u0026#34;}, {\u0026#34;%#a\u0026#34;, \u0026#34;[%#a]\u0026#34;}, {\u0026#34;% a\u0026#34;, \u0026#34;[% a]\u0026#34;}, {\u0026#34;%0a\u0026#34;, \u0026#34;[%0a]\u0026#34;}, {\u0026#34;%1.2a\u0026#34;, \u0026#34;[%1.2a]\u0026#34;}, {\u0026#34;%-1.2a\u0026#34;, \u0026#34;[%-1.2a]\u0026#34;}, {\u0026#34;%+1.2a\u0026#34;, \u0026#34;[%+1.2a]\u0026#34;}, {\u0026#34;%-+1.2a\u0026#34;, \u0026#34;[%+-1.2a]\u0026#34;}, {\u0026#34;%-+1.2abc\u0026#34;, \u0026#34;[%+-1.2a]bc\u0026#34;}, {\u0026#34;%-1.2abc\u0026#34;, \u0026#34;[%-1.2a]bc\u0026#34;}, } func TestFlagParser(t *testing.T) { var flagprinter flagPrinter for _, tt := range flagtests { t.Run(tt.in, func(t *testing.T) { s := Sprintf(tt.in, \u0026amp;flagprinter) if s != tt.out { t.Errorf(\u0026#34;got %q, want %q\u0026#34;, s, tt.out) } }) } } 通常表格是匿名结构体切片，可以定义结构体或使用已经存在的结构进行结构体数组声明。name属性用来描述特定的测试用例。\n接下来让我们试着自己编写表格驱动测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func TestSplitAll(t *testing.T) { // 定义测试表格 // 这里使用匿名结构体定义了若干个测试用例 // 并且为每个测试用例设置了一个名称 tests := []struct { name string input string sep string want []string }{ {\u0026#34;base case\u0026#34;, \u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;, []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}}, {\u0026#34;wrong sep\u0026#34;, \u0026#34;a:b:c\u0026#34;, \u0026#34;,\u0026#34;, []string{\u0026#34;a:b:c\u0026#34;}}, {\u0026#34;more sep\u0026#34;, \u0026#34;abcd\u0026#34;, \u0026#34;bc\u0026#34;, []string{\u0026#34;a\u0026#34;, \u0026#34;d\u0026#34;}}, {\u0026#34;leading sep\u0026#34;, \u0026#34;沙河有沙又有河\u0026#34;, \u0026#34;沙\u0026#34;, []string{\u0026#34;\u0026#34;, \u0026#34;河有\u0026#34;, \u0026#34;又有河\u0026#34;}}, } // 遍历测试用例 for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { // 使用t.Run()执行子测试 got := Split(tt.input, tt.sep) if !reflect.DeepEqual(got, tt.want) { t.Errorf(\u0026#34;expected:%#v, got:%#v\u0026#34;, tt.want, got) } }) } } 在终端执行go test -v，会得到如下测试输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ❯ go test -v === RUN TestSplit --- PASS: TestSplit (0.00s) === RUN TestSplitWithComplexSep --- PASS: TestSplitWithComplexSep (0.00s) === RUN TestSplitAll === RUN TestSplitAll/base_case === RUN TestSplitAll/wrong_sep === RUN TestSplitAll/more_sep === RUN TestSplitAll/leading_sep --- PASS: TestSplitAll (0.00s) --- PASS: TestSplitAll/base_case (0.00s) --- PASS: TestSplitAll/wrong_sep (0.00s) --- PASS: TestSplitAll/more_sep (0.00s) --- PASS: TestSplitAll/leading_sep (0.00s) PASS ok golang-unit-test-demo/base_demo 0.010s 并行测试 表格驱动测试中通常会定义比较多的测试用例，而Go语言又天生支持并发，所以很容易发挥自身并发优势将表格驱动测试并行化。 想要在单元测试过程中使用并行测试，可以像下面的代码示例中那样通过添加t.Parallel()来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 func TestSplitAll(t *testing.T) { t.Parallel() // 将 TLog 标记为能够与其他测试并行运行 // 定义测试表格 // 这里使用匿名结构体定义了若干个测试用例 // 并且为每个测试用例设置了一个名称 tests := []struct { name string input string sep string want []string }{ {\u0026#34;base case\u0026#34;, \u0026#34;a:b:c\u0026#34;, \u0026#34;:\u0026#34;, []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}}, {\u0026#34;wrong sep\u0026#34;, \u0026#34;a:b:c\u0026#34;, \u0026#34;,\u0026#34;, []string{\u0026#34;a:b:c\u0026#34;}}, {\u0026#34;more sep\u0026#34;, \u0026#34;abcd\u0026#34;, \u0026#34;bc\u0026#34;, []string{\u0026#34;a\u0026#34;, \u0026#34;d\u0026#34;}}, {\u0026#34;leading sep\u0026#34;, \u0026#34;沙河有沙又有河\u0026#34;, \u0026#34;沙\u0026#34;, []string{\u0026#34;\u0026#34;, \u0026#34;河有\u0026#34;, \u0026#34;又有河\u0026#34;}}, } // 遍历测试用例 for _, tt := range tests { tt := tt // 注意这里重新声明tt变量（避免多个goroutine中使用了相同的变量） t.Run(tt.name, func(t *testing.T) { // 使用t.Run()执行子测试 t.Parallel() // 将每个测试用例标记为能够彼此并行运行 got := Split(tt.input, tt.sep) if !reflect.DeepEqual(got, tt.want) { t.Errorf(\u0026#34;expected:%#v, got:%#v\u0026#34;, tt.want, got) } }) } } 这样我们执行go test -v的时候就会看到每个测试用例并不是按照我们定义的顺序执行，而是互相并行了。\n使用工具生成测试代码 社区里有很多自动生成表格驱动测试函数的工具，比如gotests等，很多编辑器如Goland也支持快速生成测试文件。这里简单演示一下gotests的使用。\n安装\n1 go get -u github.com/cweill/gotests/... 执行\n1 gotests -all -w split.go 上面的命令表示，为split.go文件的所有函数生成测试代码至split_test.go文件（目录下如果事先存在这个文件就不再生成）。\n生成的测试代码大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package base_demo import ( \u0026#34;reflect\u0026#34; \u0026#34;testing\u0026#34; ) func TestSplit(t *testing.T) { type args struct { s string sep string } tests := []struct { name string args args wantResult []string }{ // TODO: Add test cases. } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if gotResult := Split(tt.args.s, tt.args.sep); !reflect.DeepEqual(gotResult, tt.wantResult) { t.Errorf(\u0026#34;Split() = %v, want %v\u0026#34;, gotResult, tt.wantResult) } }) } } 代码格式与我们上面的类似，只需要在TODO位置添加我们的测试逻辑就可以了。\n测试覆盖率 测试覆盖率是指代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。在公司内部一般会要求测试覆盖率达到80%左右。\nGo提供内置功能来检查你的代码覆盖率，即使用go test -cover来查看测试覆盖率。\n1 2 3 4 ❯ go test -cover PASS coverage: 100.0% of statements ok golang-unit-test-demo/base_demo 0.009s 从上面的结果可以看到我们的测试用例覆盖了100%的代码。\nGo还提供了一个额外的-coverprofile参数，用来将覆盖率相关的记录信息输出到一个文件。例如：\n1 2 3 4 ❯ go test -cover -coverprofile=c.out PASS coverage: 100.0% of statements ok golang-unit-test-demo/base_demo 0.009s 上面的命令会将覆盖率相关的信息输出到当前文件夹下面的c.out文件中。\n1 2 3 4 5 ❯ tree . . ├── c.out ├── split.go └── split_test.go 然后我们执行go tool cover -html=c.out，使用cover工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个HTML报告。上图中每个用绿色标记的语句块表示被覆盖了，而红色的表示没有被覆盖。\ntestify/assert testify是一个社区非常流行的Go单元测试工具包，其中使用最多的功能就是它提供的断言工具——testify/assert或testify/require。\n安装 1 go get github.com/stretchr/testify 使用示例 我们在写单元测试的时候，通常需要使用断言来校验测试结果，但是由于Go语言官方没有提供断言，所以我们会写出很多的if...else...语句。而testify/assert为我们提供了很多常用的断言函数，并且能够输出友好、易于阅读的错误描述信息。\n比如我们之前在TestSplit测试函数中就使用了reflect.DeepEqual来判断期望结果与实际结果是否一致。\n1 2 3 4 5 6 t.Run(tt.name, func(t *testing.T) { // 使用t.Run()执行子测试 got := Split(tt.input, tt.sep) if !reflect.DeepEqual(got, tt.want) { t.Errorf(\u0026#34;expected:%#v, got:%#v\u0026#34;, tt.want, got) } }) 使用testify/assert之后就能将上述判断过程简化如下：\n1 2 3 4 t.Run(tt.name, func(t *testing.T) { // 使用t.Run()执行子测试 got := Split(tt.input, tt.sep) assert.Equal(t, got, tt.want) // 使用assert提供的断言函数 }) 当我们有多个断言语句时，还可以使用assert := assert.New(t)创建一个assert对象，它拥有前面所有的断言方法，只是不需要再传入Testing.T参数了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func TestSomething(t *testing.T) { assert := assert.New(t) // assert equality assert.Equal(123, 123, \u0026#34;they should be equal\u0026#34;) // assert inequality assert.NotEqual(123, 456, \u0026#34;they should not be equal\u0026#34;) // assert for nil (good for errors) assert.Nil(object) // assert for not nil (good when you expect something) if assert.NotNil(object) { // now we know that object isn\u0026#39;t nil, we are safe to make // further assertions without causing any errors assert.Equal(\u0026#34;Something\u0026#34;, object.Value) } } testify/assert提供了非常多的断言函数，这里没办法一一列举出来，大家可以查看官方文档了解。\ntestify/require拥有testify/assert所有断言函数，它们的唯一区别就是——testify/require遇到失败的用例会立即终止本次测试。\n此外，testify包还提供了mock、http等其他测试工具，篇幅所限这里就不详细介绍了，有兴趣的同学可以自己了解一下。\n常用限流策略——漏桶与令牌桶介绍 发布于2020/09/13 ,更新于2020/09/13 18:41:02\n| Golang\n|总阅读量：8321次\n限流又称为流量控制（流控），通常是指限制到达系统的并发请求数，本文列举了常见的限流策略，并以gin框架为例演示了如何为项目添加限流组件。\n限流 限流又称为流量控制（流控），通常是指限制到达系统的并发请求数。\n我们生活中也会经常遇到限流的场景，比如：某景区限制每日进入景区的游客数量为8万人；沙河地铁站早高峰通过站外排队逐一放行的方式限制同一时间进入车站的旅客数量等。\n限流虽然会影响部分用户的使用体验，但是却能在一定程度上报障系统的稳定性，不至于崩溃（大家都没了用户体验）。\n而互联网上类似需要限流的业务场景也有很多，比如电商系统的秒杀、微博上突发热点新闻、双十一购物节、12306抢票等等。这些场景下的用户请求量通常会激增，远远超过平时正常的请求量，此时如果不加任何限制很容易就会将后端服务打垮，影响服务的稳定性。\n此外，一些厂商公开的API服务通常也会限制用户的请求次数，比如百度地图开放平台等会根据用户的付费情况来限制用户的请求数等。\n常用的限流策略 漏桶 漏桶法限流很好理解，假设我们有一个水桶按固定的速率向下方滴落一滴水，无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。\n漏桶法的关键点在于漏桶始终按照固定的速率运行，但是它并不能很好的处理有大量突发请求的场景，毕竟在某些场景下我们可能需要提高系统的处理效率，而不是一味的按照固定速率处理请求。\n关于漏桶的实现，uber团队有一个开源的github.com/uber-go/ratelimit库。 这个库的使用方法比较简单，Take() 方法会返回漏桶下一次滴水的时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;go.uber.org/ratelimit\u0026#34; ) func main() { rl := ratelimit.New(100) // per second prev := time.Now() for i := 0; i \u0026lt; 10; i++ { now := rl.Take() fmt.Println(i, now.Sub(prev)) prev = now } // Output: // 0 0 // 1 10ms // 2 10ms // 3 10ms // 4 10ms // 5 10ms // 6 10ms // 7 10ms // 8 10ms // 9 10ms } 它的源码实现也比较简单，这里大致说一下关键的地方，有兴趣的同学可以自己去看一下完整的源码。\n限制器是一个接口类型，其要求实现一个Take()方法：\n1 2 3 4 type Limiter interface { // Take方法应该阻塞已确保满足 RPS Take() time.Time } 实现限制器接口的结构体定义如下，这里可以重点留意下maxSlack字段，它在后面的Take()方法中的处理。\n1 2 3 4 5 6 7 8 type limiter struct { sync.Mutex // 锁 last time.Time // 上一次的时刻 sleepFor time.Duration // 需要等待的时间 perRequest time.Duration // 每次的时间间隔 maxSlack time.Duration // 最大的富余量 clock Clock // 时钟 } limiter结构体实现Limiter接口的Take()方法内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Take 会阻塞确保两次请求之间的时间走完 // Take 调用平均数为 time.Second/rate. func (t *limiter) Take() time.Time { t.Lock() defer t.Unlock() now := t.clock.Now() // 如果是第一次请求就直接放行 if t.last.IsZero() { t.last = now return t.last } // sleepFor 根据 perRequest 和上一次请求的时刻计算应该sleep的时间 // 由于每次请求间隔的时间可能会超过perRequest, 所以这个数字可能为负数，并在多个请求之间累加 t.sleepFor += t.perRequest - now.Sub(t.last) // 我们不应该让sleepFor负的太多，因为这意味着一个服务在短时间内慢了很多随后会得到更高的RPS。 if t.sleepFor \u0026lt; t.maxSlack { t.sleepFor = t.maxSlack } // 如果 sleepFor 是正值那么就 sleep if t.sleepFor \u0026gt; 0 { t.clock.Sleep(t.sleepFor) t.last = now.Add(t.sleepFor) t.sleepFor = 0 } else { t.last = now } return t.last } 上面的代码根据记录每次请求的间隔时间和上一次请求的时刻来计算当次请求需要阻塞的时间——sleepFor，这里需要留意的是sleepFor的值可能为负，在经过间隔时间长的两次访问之后会导致随后大量的请求被放行，所以代码中针对这个场景有专门的优化处理。创建限制器的New()函数中会为maxSlack设置初始值，也可以通过WithoutSlack这个Option取消这个默认值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func New(rate int, opts ...Option) Limiter { l := \u0026amp;limiter{ perRequest: time.Second / time.Duration(rate), maxSlack: -10 * time.Second / time.Duration(rate), } for _, opt := range opts { opt(l) } if l.clock == nil { l.clock = clock.New() } return l } 令牌桶 令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。\n对于从桶里取不到令牌的场景，我们可以选择等待也可以直接拒绝并返回。\n对于令牌桶的Go语言实现，大家可以参照github.com/juju/ratelimit库。这个库支持多种令牌桶模式，并且使用起来也比较简单。\n创建令牌桶的方法：\n1 2 3 4 5 6 7 // 创建指定填充速率和容量大小的令牌桶 func NewBucket(fillInterval time.Duration, capacity int64) *Bucket // 创建指定填充速率、容量大小和每次填充的令牌数的令牌桶 func NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket // 创建填充速度为指定速率和容量大小的令牌桶 // NewBucketWithRate(0.1, 200) 表示每秒填充20个令牌 func NewBucketWithRate(rate float64, capacity int64) *Bucket 取出令牌的方法如下：\n1 2 3 4 5 6 7 8 9 10 // 取token（非阻塞） func (tb *Bucket) Take(count int64) time.Duration func (tb *Bucket) TakeAvailable(count int64) int64 // 最多等maxWait时间取token func (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (time.Duration, bool) // 取token（阻塞） func (tb *Bucket) Wait(count int64) func (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool 虽说是令牌桶，但是我们没有必要真的去生成令牌放到桶里，我们只需要每次来取令牌的时候计算一下，当前是否有足够的令牌就可以了，具体的计算方式可以总结为下面的公式：\n1 当前令牌数 = 上一次剩余的令牌数 + (本次取令牌的时刻-上一次取令牌的时刻)/放置令牌的时间间隔 * 每次放置的令牌数 github.com/juju/ratelimit这个库中关于令牌数计算的源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (tb *Bucket) currentTick(now time.Time) int64 { return int64(now.Sub(tb.startTime) / tb.fillInterval) } func (tb *Bucket) adjustavailableTokens(tick int64) { if tb.availableTokens \u0026gt;= tb.capacity { return } tb.availableTokens += (tick - tb.latestTick) * tb.quantum if tb.availableTokens \u0026gt; tb.capacity { tb.availableTokens = tb.capacity } tb.latestTick = tick return } 获取令牌的TakeAvailable()函数关键部分的源代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (tb *Bucket) takeAvailable(now time.Time, count int64) int64 { if count \u0026lt;= 0 { return 0 } tb.adjustavailableTokens(tb.currentTick(now)) if tb.availableTokens \u0026lt;= 0 { return 0 } if count \u0026gt; tb.availableTokens { count = tb.availableTokens } tb.availableTokens -= count return count } 大家从代码中也可以看到其实令牌桶的实现并没有很复杂。\ngin框架中使用限流中间件 在gin框架构建的项目中，我们可以将限流组件定义成中间件。\n这里使用令牌桶作为限流策略，编写一个限流中间件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 func RateLimitMiddleware(fillInterval time.Duration, cap int64) func(c *gin.Context) { bucket := ratelimit.NewBucket(fillInterval, cap) return func(c *gin.Context) { // 如果取不到令牌就中断本次请求返回 rate limit... if bucket.TakeAvailable(1) \u0026lt; 1 { c.String(http.StatusOK, \u0026#34;rate limit...\u0026#34;) c.Abort() return } c.Next() } } 对于该限流中间件的注册位置，我们可以按照不同的限流策略将其注册到不同的位置，例如：\n如果要对全站限流就可以注册成全局的中间件。 如果是某一组路由需要限流，那么就只需将该限流中间件注册到对应的路由组即可。 对于漏桶，会维护一个稳定的访问速率，通过此次访问和上一次访问的时间差，判断该时间差是否大于访问速率，若大于则会sleep若干时间，不然就可以访问。\n对于令牌桶，不会真正的实现一个桶，而是会有一个加令牌的速度，例如5个/tick，会记录一个startTime，用now-start就会得到一个时间段，该时间段除以生成令牌的间隔，就会得到当前的tick，用当前的tick减去上一次的tick再乘以速率就是当前令牌桶的令牌数字，和请求的令牌数比较一下就好了。\n完 ","date":"2023-01-05T00:00:00Z","image":"https://wolvestorm.github.io/blog/posts/gin/d8ccbe52c5255121e5a554ce275ee72d_hu7f5d8dacba1592bb3a5cf38c96474382_14659_120x120_fill_box_smart1_3.png","permalink":"https://wolvestorm.github.io/blog/posts/gin/","title":"学习Gin"}]